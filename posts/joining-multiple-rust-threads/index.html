<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/static/img/favicon.ico rel=icon type=image/x-icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css integrity=sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH rel=stylesheet><link href=/static/css/base.css rel=stylesheet><title>João Sampaio - Software Engineer</title><body><div class=container><div class="row row-top-links"><div class=col-12><p><a href=/>Home</a> <a href=/posts/>Posts</a> <a href=/atom.xml>Feed</a> <a href=/resume/>Resume</a></div></div><div class=row><div class="col-12 content"><div class="row posts-page-navigation posts-page-navigation-top"><div class=col-6></div><div class=col-6></div></div><div class=row><div class=col-12><div class=posts-page-content><h1>Joining threads immediately as they finish in Rust</h1><p class=posts-page-metadata>2025-05-15<p>As of Rust 1.87.0, if you want to manage multiple threads using exclusively the standard library, joining them immediately as they finish (in case the order in which they finish is not deterministic) is not a straightforward task.<p>This post isn’t intended as criticism of Rust’s standard library. The absence of this feature may be an intentional design decision or simply a matter of priorities. Regardless, since thread joining is a common need, I’ll document my solution for future reference.<p>When you spawn threads, you get back a <a href=https://doc.rust-lang.org/std/thread/struct.JoinHandle.html><code>JoinHandle</code></a> (this is true for <a href=https://doc.rust-lang.org/std/thread/index.html>regular</a> and <a href=https://doc.rust-lang.org/std/thread/fn.scope.html>scoped threads</a>, and they are equivalent for the purposes of this post, see <a href=https://jpmelos.com/posts/joining-multiple-rust-threads/#appendix-a-does-it-work-with-regular-threads-too>Appendix A</a>). Then, you’ll need to call <a href=https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join><code>JoinHandle.join</code></a> to join each of those threads individually. The problem is that <code>JoinHandle.join</code> blocks until the thread is finished. If you spawn multiple threads, which happens more often than not, there’s no way to wait on all of them simultaneously, and process each of them immediately as they finish.<h2 id=how-does-it-work-in-python>How does it work in Python?</h2><p>Let’s see how it can be done in another language, and then try to achieve something similar in Rust.<p>In Python, there is the <a href=https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor><code>ThreadPoolExecutor</code></a>. As you spawn threads using <a href=https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit><code>ThreadPoolExecutor.submit</code></a>, you get <a href=https://docs.python.org/3/library/concurrent.futures.html#future-objects><code>Future</code></a>s back, which you can store in an iterable. You can pass that iterable into the <a href=https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed><code>concurrent.futures.as_completed</code></a> function, and it will yield those futures as they finish. You can process each future individually right then and there, and then immediately start waiting for the next one to finish.<pre class=language-python data-lang=python data-linenos data-name=python_threads_with_threadpool.py style=color:#323232;background-color:#f1f1f1><code class=language-python data-lang=python data-name=python_threads_with_threadpool.py><table><tbody><tr><td>1<td><span style=color:#a71d5d;font-weight:700>import </span><span>concurrent</span><span style=color:#a71d5d;font-weight:700>.</span><span>futures
</span><tr><td>2<td><span style=color:#a71d5d;font-weight:700>import </span><span>time
</span><tr><td>3<td><span style=color:#a71d5d;font-weight:700>from </span><span>concurrent</span><span style=color:#a71d5d;font-weight:700>.</span><span>futures </span><span style=color:#a71d5d;font-weight:700>import </span><span>ThreadPoolExecutor
</span><tr><td>4<td><span>
</span><tr><td>5<td><span>
</span><tr><td>6<td><span style=color:#969896;font-style:italic># I'll call this function from my threads.
</span><tr><td>7<td><span style=color:#a71d5d;font-weight:700>def </span><span style=color:#323232;font-weight:700>target_fn</span><span>(sleep_duration: </span><span style=color:#0086b3>int</span><span>) -> </span><span style=color:#0086b3>int</span><span>:
</span><tr><td>8<td><span>    </span><span style=color:#62a35c>print</span><span>(</span><span style=color:#a71d5d;font-weight:700>f</span><span style=color:#183691>"Sleeping for </span><span>{sleep_duration}</span><span style=color:#183691> seconds."</span><span>)
</span><tr><td>9<td><span>    time</span><span style=color:#a71d5d;font-weight:700>.</span><span>sleep(sleep_duration)
</span><tr><td>10<td><span>    </span><span style=color:#a71d5d;font-weight:700>return </span><span>sleep_duration
</span><tr><td>11<td><span>
</span><tr><td>12<td><span>
</span><tr><td>13<td><span>start_time </span><span style=color:#a71d5d;font-weight:700>= </span><span>time</span><span style=color:#a71d5d;font-weight:700>.</span><span>monotonic()
</span><tr><td><mark style=background-color:#efefb8>14</mark><td><mark style=background-color:#efefb8><span style=color:#969896;font-style:italic># Using `ThreadPoolExecutor` as a context manager guarantees that all threads
</span></mark><tr><td><mark style=background-color:#efefb8>15</mark><td><mark style=background-color:#efefb8><span style=color:#969896;font-style:italic># will be joined before the context manager's scope ends. This is very similar
</span></mark><tr><td><mark style=background-color:#efefb8>16</mark><td><mark style=background-color:#efefb8><span style=color:#969896;font-style:italic># to Rust's scoped threads.
</span></mark><tr><td><mark style=background-color:#efefb8>17</mark><td><mark style=background-color:#efefb8><span style=color:#a71d5d;font-weight:700>with </span><span>ThreadPoolExecutor() </span><span style=color:#a71d5d;font-weight:700>as </span><span>executor:
</span></mark><tr><td><mark style=background-color:#efefb8>18</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic># Collect the futures into a set.
</span></mark><tr><td><mark style=background-color:#efefb8>19</mark><td><mark style=background-color:#efefb8><span>    futures </span><span style=color:#a71d5d;font-weight:700>= </span><span>{
</span></mark><tr><td><mark style=background-color:#efefb8>20</mark><td><mark style=background-color:#efefb8><span>        executor</span><span style=color:#a71d5d;font-weight:700>.</span><span>submit(target_fn, </span><span style=color:#0086b3>5</span><span>),
</span></mark><tr><td><mark style=background-color:#efefb8>21</mark><td><mark style=background-color:#efefb8><span>        executor</span><span style=color:#a71d5d;font-weight:700>.</span><span>submit(target_fn, </span><span style=color:#0086b3>3</span><span>),
</span></mark><tr><td><mark style=background-color:#efefb8>22</mark><td><mark style=background-color:#efefb8><span>        executor</span><span style=color:#a71d5d;font-weight:700>.</span><span>submit(target_fn, </span><span style=color:#0086b3>1</span><span>),
</span></mark><tr><td><mark style=background-color:#efefb8>23</mark><td><mark style=background-color:#efefb8><span>    }
</span></mark><tr><td><mark style=background-color:#efefb8>24</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic># Get the futures as they finish using `as_completed`.
</span></mark><tr><td><mark style=background-color:#efefb8>25</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#a71d5d;font-weight:700>for </span><span>future </span><span style=color:#a71d5d;font-weight:700>in </span><span>concurrent</span><span style=color:#a71d5d;font-weight:700>.</span><span>futures</span><span style=color:#a71d5d;font-weight:700>.</span><span>as_completed(futures):
</span></mark><tr><td>26<td><span>        time_elapsed </span><span style=color:#a71d5d;font-weight:700>= </span><span>time</span><span style=color:#a71d5d;font-weight:700>.</span><span>monotonic() </span><span style=color:#a71d5d;font-weight:700>- </span><span>start_time
</span><tr><td>27<td><span>        return_value </span><span style=color:#a71d5d;font-weight:700>= </span><span>future</span><span style=color:#a71d5d;font-weight:700>.</span><span>result()
</span><tr><td>28<td><span>        </span><span style=color:#62a35c>print</span><span>(
</span><tr><td>29<td><span>            </span><span style=color:#a71d5d;font-weight:700>f</span><span style=color:#183691>"</span><span>{time_elapsed</span><span style=color:#0086b3>:.2f</span><span>}</span><span style=color:#183691>:"
</span><tr><td>30<td><span>            </span><span style=color:#a71d5d;font-weight:700>f</span><span style=color:#183691>" Thread finished:"
</span><tr><td>31<td><span>            </span><span style=color:#a71d5d;font-weight:700>f</span><span style=color:#183691>" slept for </span><span>{return_value}</span><span style=color:#183691> seconds."
</span><tr><td>32<td><span>        )
</span></table></code></pre><p>Running the code above with Python 3.13.2 yields this (with some variation regarding the timestamps):<pre style=color:#323232;background-color:#f1f1f1><code><span>Sleeping for 5 seconds.
</span><span>Sleeping for 3 seconds.
</span><span>Sleeping for 1 seconds.
</span><span>1.00: Thread finished: slept for 1 seconds.
</span><span>3.01: Thread finished: slept for 3 seconds.
</span><span>5.01: Thread finished: slept for 5 seconds.
</span></code></pre><p>You can tell from the timestamps in the last few lines that each thread was processed as soon as it finished.<h2 id=doing-the-same-thing-in-rust>Doing the same thing in Rust</h2><p>There’s nothing like <code>concurrent.futures.as_completed</code> in Rust’s standard library. <code>JoinHandle.join</code> will block until each thread finishes, you’ll need to call it once for each thread, and you don’t know when each thread will finish.<p>The method <a href=https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.is_finished><code>JoinHandle.is_finished</code></a> can be used to check whether a thread has already finished, and it will always return immediately with a boolean. Therefore, it is possible to use it with a looping sleep to keep watch for when threads finish. But you can’t make it happen without that loop.<p>Now, all that said, I’m sure this is a solved problem. There must be a crate somewhere that solves this exact problem in an elegant and performant way. But I decided to tackle this problem myself as an opportunity to deepen my understanding of Rust’s threading model.<p>First, I’ll implement a Rust program that manages several threads using the looping approach:<pre class=language-rust data-lang=rust data-linenos data-name=rust_threads_with_looping_sleep.rs style=color:#323232;background-color:#f1f1f1><code class=language-rust data-lang=rust data-name=rust_threads_with_looping_sleep.rs><table><tbody><tr><td>1<td><span style=color:#a71d5d;font-weight:700>use </span><span>std</span><span style=color:#a71d5d;font-weight:700>::</span><span>thread;
</span><tr><td>2<td><span style=color:#a71d5d;font-weight:700>use </span><span>std</span><span style=color:#a71d5d;font-weight:700>::</span><span>time</span><span style=color:#a71d5d;font-weight:700>::</span><span>{Duration, Instant};
</span><tr><td>3<td><span>
</span><tr><td>4<td><span style=color:#969896;font-style:italic>// I'll call this function from my threads.
</span><tr><td>5<td><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>target_fn</span><span>(sleep_duration: </span><span style=color:#a71d5d;font-weight:700>u64</span><span>) -> </span><span style=color:#a71d5d;font-weight:700>u64 </span><span>{
</span><tr><td>6<td><span>    println!(</span><span style=color:#183691>"Sleeping for </span><span style=color:#0086b3>{sleep_duration}</span><span style=color:#183691> seconds."</span><span>);
</span><tr><td>7<td><span>    thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>sleep(Duration</span><span style=color:#a71d5d;font-weight:700>::</span><span>from_secs(sleep_duration));
</span><tr><td>8<td><span>    sleep_duration
</span><tr><td>9<td><span>}
</span><tr><td>10<td><span>
</span><tr><td>11<td><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>main</span><span>() {
</span><tr><td><mark style=background-color:#efefb8>12</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic>// Spawn the threads and put all the handles in a vector.
</span></mark><tr><td><mark style=background-color:#efefb8>13</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#a71d5d;font-weight:700>let mut</span><span> handles </span><span style=color:#a71d5d;font-weight:700>= </span><span>vec![
</span></mark><tr><td><mark style=background-color:#efefb8>14</mark><td><mark style=background-color:#efefb8><span>        thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>spawn(|| </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>5</span><span>)),
</span></mark><tr><td><mark style=background-color:#efefb8>15</mark><td><mark style=background-color:#efefb8><span>        thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>spawn(|| </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>3</span><span>)),
</span></mark><tr><td><mark style=background-color:#efefb8>16</mark><td><mark style=background-color:#efefb8><span>        thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>spawn(|| </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>1</span><span>)),
</span></mark><tr><td><mark style=background-color:#efefb8>17</mark><td><mark style=background-color:#efefb8><span>    ];
</span></mark><tr><td>18<td><span>
</span><tr><td>19<td><span>    </span><span style=color:#a71d5d;font-weight:700>let</span><span> start_time </span><span style=color:#a71d5d;font-weight:700>= </span><span>Instant</span><span style=color:#a71d5d;font-weight:700>::</span><span>now();
</span><tr><td>20<td><span>    </span><span style=color:#a71d5d;font-weight:700>while !</span><span>handles</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>is_empty</span><span>() {
</span><tr><td>21<td><span>        </span><span style=color:#a71d5d;font-weight:700>let mut</span><span> i </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#0086b3>0</span><span>;
</span><tr><td>22<td><span>
</span><tr><td>23<td><span>        </span><span style=color:#a71d5d;font-weight:700>while</span><span> i </span><span style=color:#a71d5d;font-weight:700><</span><span> handles</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>len</span><span>() {
</span><tr><td><mark style=background-color:#efefb8>24</mark><td><mark style=background-color:#efefb8><span>            </span><span style=color:#969896;font-style:italic>// Call `JoinHandle.is_finished` for each thread, until one of them is.
</span></mark><tr><td><mark style=background-color:#efefb8>25</mark><td><mark style=background-color:#efefb8><span>            </span><span style=color:#a71d5d;font-weight:700>if</span><span> handles[i]</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>is_finished</span><span>() {
</span></mark><tr><td>26<td><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> handles</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>remove</span><span>(i);
</span><tr><td><mark style=background-color:#efefb8>27</mark><td><mark style=background-color:#efefb8><span>                </span><span style=color:#969896;font-style:italic>// Call `JoinHandle.join`, get the result, print it.
</span></mark><tr><td><mark style=background-color:#efefb8>28</mark><td><mark style=background-color:#efefb8><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> sleep_duration </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>join</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span></mark><tr><td>29<td><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> time_elapsed </span><span style=color:#a71d5d;font-weight:700>=</span><span> start_time</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>elapsed</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>as_secs_f64</span><span>();
</span><tr><td>30<td><span>                println!(</span><span style=color:#183691>"</span><span style=color:#0086b3>{time_elapsed:.2}</span><span style=color:#183691>: Thread finished: slept for </span><span style=color:#0086b3>{sleep_duration}</span><span style=color:#183691> seconds."</span><span>);
</span><tr><td>31<td><span>            } </span><span style=color:#a71d5d;font-weight:700>else </span><span>{
</span><tr><td>32<td><span>                i </span><span style=color:#a71d5d;font-weight:700>+= </span><span style=color:#0086b3>1</span><span>;
</span><tr><td>33<td><span>            }
</span><tr><td>34<td><span>        }
</span><tr><td>35<td><span>
</span><tr><td><mark style=background-color:#efefb8>36</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// Sleep, the main thread yields control so the others can continue.
</span></mark><tr><td><mark style=background-color:#efefb8>37</mark><td><mark style=background-color:#efefb8><span>        thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>sleep(Duration</span><span style=color:#a71d5d;font-weight:700>::</span><span>from_millis(</span><span style=color:#0086b3>10</span><span>));
</span></mark><tr><td>38<td><span>    }
</span><tr><td>39<td><span>}
</span></table></code></pre><p>Here’s the output from that program:<pre style=color:#323232;background-color:#f1f1f1><code><span>Sleeping for 5 seconds.
</span><span>Sleeping for 1 seconds.
</span><span>Sleeping for 3 seconds.
</span><span>1.00: Thread finished: slept for 1 seconds.
</span><span>3.00: Thread finished: slept for 3 seconds.
</span><span>5.01: Thread finished: slept for 5 seconds.
</span></code></pre><p>That’s not terrible, but what if you don’t want to loop? I encountered this problem when writing <a href=https://github.com/jpmelos/fdintercept><code>fdintercept</code></a>.<h2 id=self-shipping-threads-in-rust>“Self-shipping” threads in Rust</h2><p>The solution that I found in Rust is this: let each spawned thread communicate to the parent thread when it has finished. This can be done via regular <a href=https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html><code>mpsc</code> channels</a>, and thus the parent thread just needs to wait for something to arrive over the channel instead of looping.<p>First, I wrote a function that spawns a new thread inside an existing thread scope, but this is a special thread: it will send its own handle to the parent thread. In my code, I call it a “self-shipping thread”. The function also receives the target function that we want to run in the new thread.<p>Let’s see how this function is implemented below, and then we’ll go through it step by step.<pre class=language-rust data-lang=rust data-linenos data-name=rust_self_shipping_threads_naive.rs style=color:#323232;background-color:#f1f1f1><code class=language-rust data-lang=rust data-name=rust_self_shipping_threads_naive.rs><table><tbody><tr><td>7<td><span style=color:#a71d5d;font-weight:700>pub fn </span><span style=color:#795da3;font-weight:700>spawn_self_shipping_thread_in_scope</span><span><</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, F, R>(
</span><tr><td>8<td><span>    scope: </span><span style=color:#a71d5d;font-weight:700>&'scope </span><span>thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>Scope<</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, '</span><span style=color:#a71d5d;font-weight:700>_</span><span>>,
</span><tr><td><mark style=background-color:#efefb8>9</mark><td><mark style=background-color:#efefb8><span>    tx: mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>Sender&LTScopedJoinHandle<</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, R>>,
</span></mark><tr><td>10<td><span>    func: F,
</span><tr><td>11<td><span>) </span><span style=color:#a71d5d;font-weight:700>where
</span><tr><td>12<td><span>    F: FnOnce() -> R + Send + </span><span style=color:#a71d5d;font-weight:700>'scope</span><span>,
</span><tr><td>13<td><span>    R: Send + </span><span style=color:#a71d5d;font-weight:700>'scope</span><span>,
</span><tr><td>14<td><span>{
</span><tr><td><mark style=background-color:#efefb8>15</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic>// Create the channel that will be used to transfer the new thread's handle from the parent
</span></mark><tr><td><mark style=background-color:#efefb8>16</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic>// thread to the new thread.
</span></mark><tr><td><mark style=background-color:#efefb8>17</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#a71d5d;font-weight:700>let </span><span>(handle_tx, handle_rx) </span><span style=color:#a71d5d;font-weight:700>= </span><span>mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>channel();
</span></mark><tr><td>18<td><span>
</span><tr><td><mark style=background-color:#efefb8>19</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic>// Spawn the new thread in the scope.
</span></mark><tr><td><mark style=background-color:#efefb8>20</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> scope</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>spawn</span><span>(</span><span style=color:#a71d5d;font-weight:700>move || </span><span>{
</span></mark><tr><td><mark style=background-color:#efefb8>21</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// Execute the target function.
</span></mark><tr><td><mark style=background-color:#efefb8>22</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#a71d5d;font-weight:700>let</span><span> result </span><span style=color:#a71d5d;font-weight:700>= </span><span style=color:#62a35c>func</span><span>();
</span></mark><tr><td>23<td><span>
</span><tr><td><mark style=background-color:#efefb8>24</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// Receive the handler that was sent by the parent thread to the new thread via the
</span></mark><tr><td><mark style=background-color:#efefb8>25</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// channel.
</span></mark><tr><td><mark style=background-color:#efefb8>26</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle_rx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>recv</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span></mark><tr><td><mark style=background-color:#efefb8>27</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// And immediately send it to the caller of `spawn_self_shipping_thread_in_scope`. It is
</span></mark><tr><td><mark style=background-color:#efefb8>28</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// responsibility of the caller to make sure that the `rx` side of this channel is alive
</span></mark><tr><td><mark style=background-color:#efefb8>29</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// until after this thread is finished.
</span></mark><tr><td><mark style=background-color:#efefb8>30</mark><td><mark style=background-color:#efefb8><span>        tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>send</span><span>(handle)</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span></mark><tr><td>31<td><span>
</span><tr><td><mark style=background-color:#efefb8>32</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// Return the same result as the target function.
</span></mark><tr><td><mark style=background-color:#efefb8>33</mark><td><mark style=background-color:#efefb8><span>        result
</span></mark><tr><td>34<td><span>    });
</span><tr><td>35<td><span>
</span><tr><td><mark style=background-color:#efefb8>36</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic>// Send the new thread's handle into the new thread itself.
</span></mark><tr><td><mark style=background-color:#efefb8>37</mark><td><mark style=background-color:#efefb8><span>    handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>send</span><span>(handle)</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span></mark><tr><td>38<td><span>}
</span></table></code></pre><p>The function receives three things: the thread scope in which the new threads will be created, the channel’s sending end which will be used the send the thread handle to the caller of <code>spawn_self_shipping_thread_in_scope</code>, and the target function we want to run in the new thread.<p>The function uses two channels:<ol><li>From parent thread to new thread: sends the handle to the new thread (created in line 17, used in lines 26 and 37).<li>From new thread to caller: returns the handle when the thread is finished (received from the caller in line 9, used in line 30).</ol><p>The parent thread creates the first channel, spawns the new thread, and sends the handle to it. Meanwhile, the new thread executes the target function, receives its own handle via the first channel, and sends it back to the caller through the second channel before returning the function’s result.<p>This is how <code>spawn_self_shipping_thread_in_scope</code> can be used:<pre class=language-rust data-lang=rust data-linenos data-name=rust_self_shipping_threads_naive.rs style=color:#323232;background-color:#f1f1f1><code class=language-rust data-lang=rust data-name=rust_self_shipping_threads_naive.rs><table><tbody><tr><td>40<td><span style=color:#969896;font-style:italic>// I'll call this function from my threads.
</span><tr><td>41<td><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>target_fn</span><span>(sleep_duration: </span><span style=color:#a71d5d;font-weight:700>u64</span><span>) -> </span><span style=color:#a71d5d;font-weight:700>u64 </span><span>{
</span><tr><td>42<td><span>    println!(</span><span style=color:#183691>"Sleeping for </span><span style=color:#0086b3>{sleep_duration}</span><span style=color:#183691> seconds."</span><span>);
</span><tr><td>43<td><span>    thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>sleep(Duration</span><span style=color:#a71d5d;font-weight:700>::</span><span>from_secs(sleep_duration));
</span><tr><td>44<td><span>    sleep_duration
</span><tr><td>45<td><span>}
</span><tr><td>46<td><span>
</span><tr><td><mark style=background-color:#efefb8>47</mark><td><mark style=background-color:#efefb8><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>main</span><span>() {
</span></mark><tr><td><mark style=background-color:#efefb8>48</mark><td><mark style=background-color:#efefb8><span>    </span><span style=color:#969896;font-style:italic>// Create the thread scope.
</span></mark><tr><td><mark style=background-color:#efefb8>49</mark><td><mark style=background-color:#efefb8><span>    thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>scope(</span><span style=color:#a71d5d;font-weight:700>move |</span><span>scope</span><span style=color:#a71d5d;font-weight:700>| </span><span>{
</span></mark><tr><td><mark style=background-color:#efefb8>50</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// Create the channel that the new threads will use to send their handles to the main
</span></mark><tr><td><mark style=background-color:#efefb8>51</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// thread.
</span></mark><tr><td><mark style=background-color:#efefb8>52</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#a71d5d;font-weight:700>let </span><span>(handle_tx, handle_rx) </span><span style=color:#a71d5d;font-weight:700>= </span><span>mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>channel();
</span></mark><tr><td>53<td><span>
</span><tr><td><mark style=background-color:#efefb8>54</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// Spawn the new threads.
</span></mark><tr><td><mark style=background-color:#efefb8>55</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#62a35c>spawn_self_shipping_thread_in_scope</span><span>(scope, handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>clone</span><span>(), || </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>1</span><span>));
</span></mark><tr><td><mark style=background-color:#efefb8>56</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#62a35c>spawn_self_shipping_thread_in_scope</span><span>(scope, handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>clone</span><span>(), || </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>3</span><span>));
</span></mark><tr><td><mark style=background-color:#efefb8>57</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#62a35c>spawn_self_shipping_thread_in_scope</span><span>(scope, handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>clone</span><span>(), || </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>5</span><span>));
</span></mark><tr><td>58<td><span>
</span><tr><td>59<td><span>        </span><span style=color:#969896;font-style:italic>// Drop this `handle_tx` so that when all the threads are finished and all the `handle_tx`
</span><tr><td>60<td><span>        </span><span style=color:#969896;font-style:italic>// clones are dropped, `handle_rx` will return `Err`.
</span><tr><td>61<td><span>        </span><span style=color:#62a35c>drop</span><span>(handle_tx);
</span><tr><td>62<td><span>
</span><tr><td>63<td><span>        </span><span style=color:#a71d5d;font-weight:700>let</span><span> start_time </span><span style=color:#a71d5d;font-weight:700>= </span><span>Instant</span><span style=color:#a71d5d;font-weight:700>::</span><span>now();
</span><tr><td><mark style=background-color:#efefb8>64</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// Receive the handle from the next thread that finishes.
</span></mark><tr><td><mark style=background-color:#efefb8>65</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#a71d5d;font-weight:700>while let </span><span style=color:#0086b3>Ok</span><span>(handle) </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle_rx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>recv</span><span>() {
</span></mark><tr><td><mark style=background-color:#efefb8>66</mark><td><mark style=background-color:#efefb8><span>            </span><span style=color:#969896;font-style:italic>// Join the thread and get the result.
</span></mark><tr><td><mark style=background-color:#efefb8>67</mark><td><mark style=background-color:#efefb8><span>            </span><span style=color:#a71d5d;font-weight:700>match</span><span> handle</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>join</span><span>() {
</span></mark><tr><td>68<td><span>                </span><span style=color:#0086b3>Ok</span><span>(sleep_duration) </span><span style=color:#a71d5d;font-weight:700>=> </span><span>{
</span><tr><td>69<td><span>                    </span><span style=color:#a71d5d;font-weight:700>let</span><span> time_elapsed </span><span style=color:#a71d5d;font-weight:700>=</span><span> start_time</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>elapsed</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>as_secs_f64</span><span>();
</span><tr><td>70<td><span>                    println!(
</span><tr><td>71<td><span>                        </span><span style=color:#183691>"</span><span style=color:#0086b3>{time_elapsed:.2}</span><span style=color:#183691>: Thread finished: slept for </span><span style=color:#0086b3>{sleep_duration}</span><span style=color:#183691> seconds."
</span><tr><td>72<td><span>                    );
</span><tr><td>73<td><span>                }
</span><tr><td>74<td><span>                </span><span style=color:#0086b3>Err</span><span>(e) </span><span style=color:#a71d5d;font-weight:700>=> </span><span>eprintln!(</span><span style=color:#183691>"Error joining thread: </span><span style=color:#0086b3>{e:?}</span><span style=color:#183691>"</span><span>),
</span><tr><td>75<td><span>            }
</span><tr><td>76<td><span>        }
</span><tr><td>77<td><span>    });
</span><tr><td>78<td><span>}
</span></table></code></pre><p>When spawning the threads, you need to create the scope and the channel, spawn the threads by calling <code>spawn_self_shipping_thread_in_scope</code> while passing the scope, the <code>handle_tx</code> side of the channel, and the target function, and then just wait on the <code>handle_rx</code> side for the handles. As handles arrive, it is guaranteed that their threads have completed.<p>This is the result:<pre style=color:#323232;background-color:#f1f1f1><code><span>Sleeping for 1 seconds.
</span><span>Sleeping for 3 seconds.
</span><span>Sleeping for 5 seconds.
</span><span>1.01: Thread finished: slept for 1 seconds.
</span><span>3.00: Thread finished: slept for 3 seconds.
</span><span>5.00: Thread finished: slept for 5 seconds.
</span></code></pre><h2 id=but-what-if-the-thread-panics>But what if the thread panics?</h2><p>But the code above has a fatal flaw: what if the thread panics? Then, it won’t send the handle to the parent thread. Although the thread will eventually be joined when the scope ends, it will bypass our custom processing logic.<p>Let’s fix that.<p>First, let’s write a test that proves that we have a problem and that we can later use to prove that we have fixed the issue.<pre class=language-rust data-lang=rust data-linenos data-name=rust_self_shipping_threads_naive.rs style=color:#323232;background-color:#f1f1f1><code class=language-rust data-lang=rust data-name=rust_self_shipping_threads_naive.rs><table><tbody><tr><td>87<td><span>        #[test]
</span><tr><td>88<td><span>        </span><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>handles_panic</span><span>() {
</span><tr><td>89<td><span>            </span><span style=color:#969896;font-style:italic>// Create the thread scope.
</span><tr><td>90<td><span>            thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>scope(|scope| {
</span><tr><td>91<td><span>                </span><span style=color:#969896;font-style:italic>// And the channel.
</span><tr><td>92<td><span>                </span><span style=color:#a71d5d;font-weight:700>let </span><span>(tx, rx) </span><span style=color:#a71d5d;font-weight:700>= </span><span>mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>channel();
</span><tr><td>93<td><span>
</span><tr><td>94<td><span>                </span><span style=color:#969896;font-style:italic>// Spawn the self-shipping thread. Make it panic.
</span><tr><td>95<td><span>                </span><span style=color:#62a35c>spawn_self_shipping_thread_in_scope</span><span>(scope, tx, || {
</span><tr><td>96<td><span>                    panic!(</span><span style=color:#183691>"Thread is panicking on purpose for testing"</span><span>);
</span><tr><td>97<td><span>                });
</span><tr><td>98<td><span>
</span><tr><td><mark style=background-color:#efefb8>99</mark><td><mark style=background-color:#efefb8><span>                </span><span style=color:#969896;font-style:italic>// Ensure something was sent over the channel.
</span></mark><tr><td><mark style=background-color:#efefb8>100</mark><td><mark style=background-color:#efefb8><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> rx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>recv</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span></mark><tr><td>101<td><span>                </span><span style=color:#969896;font-style:italic>// Join the self-shipping thread.
</span><tr><td>102<td><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> join_result </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>join</span><span>();
</span><tr><td>103<td><span>                </span><span style=color:#969896;font-style:italic>// And see that it errored with our custom panic message.
</span><tr><td>104<td><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> err </span><span style=color:#a71d5d;font-weight:700>=</span><span> join_result</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap_err</span><span>();
</span><tr><td>105<td><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> panic_msg </span><span style=color:#a71d5d;font-weight:700>=</span><span> err</span><span style=color:#a71d5d;font-weight:700>.</span><span>downcast_ref</span><span style=color:#a71d5d;font-weight:700>::</span><span><</span><span style=color:#a71d5d;font-weight:700>&str</span><span>>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>106<td><span>                assert!(panic_msg</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>contains</span><span>(</span><span style=color:#183691>"Thread is panicking on purpose for testing"</span><span>));
</span><tr><td>107<td><span>            });
</span><tr><td>108<td><span>        }
</span></table></code></pre><p>Running the test, this is what we get:<pre style=color:#323232;background-color:#f1f1f1><code><span>thread 'tests::spawn_self_shipping_thread_in_scope::handles_panic' panicked at src/main.rs:98:40:
</span><span>called `Result::unwrap()` on an `Err` value: RecvError
</span></code></pre><p>The error comes from line 100: since nothing was ever sent into the channel before it was closed, calling <a href=https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv><code>recv</code></a> on it causes it to return an <code>Err</code>.<p>So, how do we make the test pass?<p>The idea here is this: no matter what happens, we always want the thread handle to be sent to the caller of <code>spawn_self_shipping_thread_in_scope</code>, even if the thread panics.<p>When a Rust function panics, it goes through a process called <a href=https://doc.rust-lang.org/nomicon/unwinding.html>“unwinding”</a>. During this process, everything in the thread stack is dropped as usual. <a href=https://doc.rust-lang.org/std/ops/trait.Drop.html><code>Drop</code></a> implementations are still respected after panics! So we need to implement something that, when dropped, will send the handle through the channel.<p>What would such a thing look like? Let’s take a look.<pre class=language-rust data-lang=rust data-linenos data-name=rust_self_shipping_threads.rs style=color:#323232;background-color:#f1f1f1><code class=language-rust data-lang=rust data-name=rust_self_shipping_threads.rs><table><tbody><tr><td>7<td><span style=color:#969896;font-style:italic>// A struct with a `Drop` implementation to ensure the thread handle is sent to the caller of
</span><tr><td>8<td><span style=color:#969896;font-style:italic>// `spawn_self_shipping_thread_in_scope` even if the self-shipping thread panics.
</span><tr><td>9<td><span style=color:#a71d5d;font-weight:700>struct </span><span>SendOnDrop<</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, R> {
</span><tr><td>10<td><span>    handle: </span><span style=color:#0086b3>Option</span><span>&LTScopedJoinHandle<</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, R>>,
</span><tr><td>11<td><span>    tx: mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>Sender&LTScopedJoinHandle<</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, R>>,
</span><tr><td>12<td><span>}
</span><tr><td>13<td><span>
</span><tr><td>14<td><span style=color:#a71d5d;font-weight:700>impl</span><span>&LTR> Drop </span><span style=color:#a71d5d;font-weight:700>for </span><span>SendOnDrop<'</span><span style=color:#a71d5d;font-weight:700>_</span><span>, R> {
</span><tr><td>15<td><span>    </span><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>drop</span><span>(</span><span style=color:#a71d5d;font-weight:700>&mut </span><span>self) {
</span><tr><td>16<td><span>        </span><span style=color:#a71d5d;font-weight:700>if let </span><span style=color:#0086b3>Some</span><span>(handle) </span><span style=color:#a71d5d;font-weight:700>= </span><span>self</span><span style=color:#a71d5d;font-weight:700>.</span><span>handle</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>take</span><span>() {
</span><tr><td>17<td><span>            self</span><span style=color:#a71d5d;font-weight:700>.</span><span>tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>send</span><span>(handle)</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>18<td><span>        }
</span><tr><td>19<td><span>    }
</span><tr><td>20<td><span>}
</span></table></code></pre><p>The struct <code>SendOnDrop</code> is something that owns the thread handle and <code>tx</code> (the sending end of the channel created by the caller of <code>spawn_self_shipping_thread_in_scope</code>). It implements the <code>Drop</code> trait, which requires an implementation for the <a href=https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop><code>Drop.drop</code></a> method, and this is the method that runs when <code>SendOnDrop</code> is dropped.<p>The <code>Drop.drop</code> method will take ownership of the handle (that’s why its created as a <code>Option&LTScopedJoinHandle<'scope, R>></code> on the struct, so we can take ownership of it and leave a <code>None</code> in its place), and send it through the channel.<p>And here’s the version of <code>spawn_self_shipping_thread_in_scope</code> that makes use of the <code>SendOnDrop</code> struct:<pre class=language-rust data-lang=rust data-linenos data-name=rust_self_shipping_threads.rs style=color:#323232;background-color:#f1f1f1><code class=language-rust data-lang=rust data-name=rust_self_shipping_threads.rs><table><tbody><tr><td>22<td><span style=color:#a71d5d;font-weight:700>pub fn </span><span style=color:#795da3;font-weight:700>spawn_self_shipping_thread_in_scope</span><span><</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, F, R>(
</span><tr><td>23<td><span>    scope: </span><span style=color:#a71d5d;font-weight:700>&'scope </span><span>thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>Scope<</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, '</span><span style=color:#a71d5d;font-weight:700>_</span><span>>,
</span><tr><td>24<td><span>    tx: mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>Sender&LTScopedJoinHandle<</span><span style=color:#a71d5d;font-weight:700>'scope</span><span>, R>>,
</span><tr><td>25<td><span>    func: F,
</span><tr><td>26<td><span>) </span><span style=color:#a71d5d;font-weight:700>where
</span><tr><td>27<td><span>    F: FnOnce() -> R + Send + </span><span style=color:#a71d5d;font-weight:700>'scope</span><span>,
</span><tr><td>28<td><span>    R: Send + </span><span style=color:#a71d5d;font-weight:700>'scope</span><span>,
</span><tr><td>29<td><span>{
</span><tr><td>30<td><span>    </span><span style=color:#969896;font-style:italic>// Create the channel that will be used to transfer the new thread's handle from the parent
</span><tr><td>31<td><span>    </span><span style=color:#969896;font-style:italic>// thread to the new thread.
</span><tr><td>32<td><span>    </span><span style=color:#a71d5d;font-weight:700>let </span><span>(handle_tx, handle_rx) </span><span style=color:#a71d5d;font-weight:700>= </span><span>mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>channel();
</span><tr><td>33<td><span>
</span><tr><td>34<td><span>    </span><span style=color:#969896;font-style:italic>// Spawn the new thread in the scope.
</span><tr><td>35<td><span>    </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> scope</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>spawn</span><span>(</span><span style=color:#a71d5d;font-weight:700>move || </span><span>{
</span><tr><td>36<td><span>        </span><span style=color:#969896;font-style:italic>// Receive the handler that was sent by the parent thread to the new thread via the
</span><tr><td>37<td><span>        </span><span style=color:#969896;font-style:italic>// channel.
</span><tr><td>38<td><span>        </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle_rx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>recv</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>39<td><span>
</span><tr><td><mark style=background-color:#efefb8>40</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// This will send the new thread's handle to the caller of
</span></mark><tr><td><mark style=background-color:#efefb8>41</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// `spawn_self_shipping_thread_in_scope` when the thread stack is destroyed, even if that
</span></mark><tr><td><mark style=background-color:#efefb8>42</mark><td><mark style=background-color:#efefb8><span>        </span><span style=color:#969896;font-style:italic>// happens due to a panic.
</span></mark><tr><td><mark style=background-color:#efefb8>43</mark><td><mark style=background-color:#efefb8><span>        SendOnDrop {
</span></mark><tr><td><mark style=background-color:#efefb8>44</mark><td><mark style=background-color:#efefb8><span>            handle: </span><span style=color:#0086b3>Some</span><span>(handle),
</span></mark><tr><td><mark style=background-color:#efefb8>45</mark><td><mark style=background-color:#efefb8><span>            </span><span style=color:#969896;font-style:italic>// It is responsibility of the caller to make sure that the `rx` side of this
</span></mark><tr><td><mark style=background-color:#efefb8>46</mark><td><mark style=background-color:#efefb8><span>            </span><span style=color:#969896;font-style:italic>// channel is alive until after this thread is finished.
</span></mark><tr><td><mark style=background-color:#efefb8>47</mark><td><mark style=background-color:#efefb8><span>            tx,
</span></mark><tr><td><mark style=background-color:#efefb8>48</mark><td><mark style=background-color:#efefb8><span>        };
</span></mark><tr><td>49<td><span>
</span><tr><td>50<td><span>        </span><span style=color:#969896;font-style:italic>// Execute the target function and return its result.
</span><tr><td>51<td><span>        </span><span style=color:#62a35c>func</span><span>()
</span><tr><td>52<td><span>    });
</span><tr><td>53<td><span>
</span><tr><td>54<td><span>    </span><span style=color:#969896;font-style:italic>// Send the new thread's handle into the new thread itself.
</span><tr><td>55<td><span>    handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>send</span><span>(handle)</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>56<td><span>}
</span></table></code></pre><p>The body of the self-shipping thread changed significantly: now, the first thing it does is get the handle from the parent thread. Then, it creates a <code>SendOnDrop</code> struct on the stack. We don’t even need to give it a name: as long as it is sitting on the stack, it will be properly dropped in the event of a panic, or when the thread finishes.<p>Then, we run the target function and return its result.<p>And now, if we run the test from before, it passes! We now have self-shipping threads that we can act on immediately as they return, and they will still notify the caller of <code>spawn_self_shipping_thread_in_scope</code> when they finish, even if that happens because of a panic.<h2 id=appendix-a-does-it-work-with-regular-threads-too>Appendix A: Does it work with regular threads too?</h2><p>This works with regular threads too, not only scoped threads. See the code below.<pre class=language-rust data-lang=rust data-linenos data-name=rust_self_shipping_regular_threads.rs style=color:#323232;background-color:#f1f1f1><code class=language-rust data-lang=rust data-name=rust_self_shipping_regular_threads.rs><table><tbody><tr><td>1<td><span style=color:#a71d5d;font-weight:700>use </span><span>std</span><span style=color:#a71d5d;font-weight:700>::</span><span>{
</span><tr><td>2<td><span>    sync</span><span style=color:#a71d5d;font-weight:700>::</span><span>mpsc,
</span><tr><td>3<td><span>    thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>{self, JoinHandle},
</span><tr><td>4<td><span>    time</span><span style=color:#a71d5d;font-weight:700>::</span><span>{Duration, Instant},
</span><tr><td>5<td><span>};
</span><tr><td>6<td><span>
</span><tr><td>7<td><span style=color:#969896;font-style:italic>// A struct with a `Drop` implementation to ensure the thread handle is sent to the caller of
</span><tr><td>8<td><span style=color:#969896;font-style:italic>// `spawn_self_shipping_thread` even if the self-shipping thread panics.
</span><tr><td>9<td><span style=color:#a71d5d;font-weight:700>struct </span><span>SendOnDrop&LTR> {
</span><tr><td>10<td><span>    handle: </span><span style=color:#0086b3>Option</span><span>&LTJoinHandle&LTR>>,
</span><tr><td>11<td><span>    tx: mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>Sender&LTJoinHandle&LTR>>,
</span><tr><td>12<td><span>}
</span><tr><td>13<td><span>
</span><tr><td>14<td><span style=color:#a71d5d;font-weight:700>impl</span><span>&LTR> Drop </span><span style=color:#a71d5d;font-weight:700>for </span><span>SendOnDrop&LTR> {
</span><tr><td>15<td><span>    </span><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>drop</span><span>(</span><span style=color:#a71d5d;font-weight:700>&mut </span><span>self) {
</span><tr><td>16<td><span>        </span><span style=color:#a71d5d;font-weight:700>if let </span><span style=color:#0086b3>Some</span><span>(handle) </span><span style=color:#a71d5d;font-weight:700>= </span><span>self</span><span style=color:#a71d5d;font-weight:700>.</span><span>handle</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>take</span><span>() {
</span><tr><td>17<td><span>            self</span><span style=color:#a71d5d;font-weight:700>.</span><span>tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>send</span><span>(handle)</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>18<td><span>        }
</span><tr><td>19<td><span>    }
</span><tr><td>20<td><span>}
</span><tr><td>21<td><span>
</span><tr><td>22<td><span style=color:#a71d5d;font-weight:700>pub fn </span><span style=color:#795da3;font-weight:700>spawn_self_shipping_thread</span><span>&LTF, R>(tx: mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>Sender&LTJoinHandle&LTR>>, func: F)
</span><tr><td>23<td><span style=color:#a71d5d;font-weight:700>where
</span><tr><td>24<td><span>    F: FnOnce() -> R + Send + </span><span style=color:#a71d5d;font-weight:700>'static</span><span>,
</span><tr><td>25<td><span>    R: Send + </span><span style=color:#a71d5d;font-weight:700>'static</span><span>,
</span><tr><td>26<td><span>{
</span><tr><td>27<td><span>    </span><span style=color:#969896;font-style:italic>// Create the channel that will be used to transfer the new thread's handle from the parent
</span><tr><td>28<td><span>    </span><span style=color:#969896;font-style:italic>// thread to the new thread.
</span><tr><td>29<td><span>    </span><span style=color:#a71d5d;font-weight:700>let </span><span>(handle_tx, handle_rx) </span><span style=color:#a71d5d;font-weight:700>= </span><span>mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>channel();
</span><tr><td>30<td><span>
</span><tr><td>31<td><span>    </span><span style=color:#969896;font-style:italic>// Spawn the new thread in the scope.
</span><tr><td>32<td><span>    </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>= </span><span>std</span><span style=color:#a71d5d;font-weight:700>::</span><span>thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>spawn(</span><span style=color:#a71d5d;font-weight:700>move || </span><span>{
</span><tr><td>33<td><span>        </span><span style=color:#969896;font-style:italic>// Receive the handler that was sent by the parent thread to the new thread via the
</span><tr><td>34<td><span>        </span><span style=color:#969896;font-style:italic>// channel.
</span><tr><td>35<td><span>        </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle_rx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>recv</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>36<td><span>
</span><tr><td>37<td><span>        </span><span style=color:#969896;font-style:italic>// This will send the new thread's handle to the caller of
</span><tr><td>38<td><span>        </span><span style=color:#969896;font-style:italic>// `spawn_self_shipping_thread_in_scope` when the thread stack is destroyed, even if that
</span><tr><td>39<td><span>        </span><span style=color:#969896;font-style:italic>// happens due to a panic.
</span><tr><td>40<td><span>        SendOnDrop {
</span><tr><td>41<td><span>            handle: </span><span style=color:#0086b3>Some</span><span>(handle),
</span><tr><td>42<td><span>            </span><span style=color:#969896;font-style:italic>// It is responsibility of the caller to make sure that the `rx` side of this channel
</span><tr><td>43<td><span>            </span><span style=color:#969896;font-style:italic>// is alive until after this thread is finished.
</span><tr><td>44<td><span>            tx,
</span><tr><td>45<td><span>        };
</span><tr><td>46<td><span>
</span><tr><td>47<td><span>        </span><span style=color:#969896;font-style:italic>// Execute the target function and return its result.
</span><tr><td>48<td><span>        </span><span style=color:#62a35c>func</span><span>()
</span><tr><td>49<td><span>    });
</span><tr><td>50<td><span>
</span><tr><td>51<td><span>    </span><span style=color:#969896;font-style:italic>// Send the new thread's handle into the new thread itself.
</span><tr><td>52<td><span>    handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>send</span><span>(handle)</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>53<td><span>}
</span><tr><td>54<td><span>
</span><tr><td>55<td><span style=color:#969896;font-style:italic>// I'll call this function from my threads.
</span><tr><td>56<td><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>target_fn</span><span>(sleep_duration: </span><span style=color:#a71d5d;font-weight:700>u64</span><span>) -> </span><span style=color:#a71d5d;font-weight:700>u64 </span><span>{
</span><tr><td>57<td><span>    println!(</span><span style=color:#183691>"Sleeping for </span><span style=color:#0086b3>{sleep_duration}</span><span style=color:#183691> seconds."</span><span>);
</span><tr><td>58<td><span>    thread</span><span style=color:#a71d5d;font-weight:700>::</span><span>sleep(Duration</span><span style=color:#a71d5d;font-weight:700>::</span><span>from_secs(sleep_duration));
</span><tr><td>59<td><span>    sleep_duration
</span><tr><td>60<td><span>}
</span><tr><td>61<td><span>
</span><tr><td>62<td><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>main</span><span>() {
</span><tr><td>63<td><span>    </span><span style=color:#969896;font-style:italic>// Create the channel that the new threads will use to send their handles to the main thread.
</span><tr><td>64<td><span>    </span><span style=color:#a71d5d;font-weight:700>let </span><span>(handle_tx, handle_rx) </span><span style=color:#a71d5d;font-weight:700>= </span><span>mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>channel();
</span><tr><td>65<td><span>
</span><tr><td>66<td><span>    </span><span style=color:#969896;font-style:italic>// Spawn the new threads.
</span><tr><td>67<td><span>    </span><span style=color:#62a35c>spawn_self_shipping_thread</span><span>(handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>clone</span><span>(), || </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>1</span><span>));
</span><tr><td>68<td><span>    </span><span style=color:#62a35c>spawn_self_shipping_thread</span><span>(handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>clone</span><span>(), || </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>3</span><span>));
</span><tr><td>69<td><span>    </span><span style=color:#62a35c>spawn_self_shipping_thread</span><span>(handle_tx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>clone</span><span>(), || </span><span style=color:#62a35c>target_fn</span><span>(</span><span style=color:#0086b3>5</span><span>));
</span><tr><td>70<td><span>
</span><tr><td>71<td><span>    </span><span style=color:#969896;font-style:italic>// Drop this `handle_tx` so that when all the threads are finished and all the `handle_tx`
</span><tr><td>72<td><span>    </span><span style=color:#969896;font-style:italic>// clones are dropped, `handle_rx` will return `Err`.
</span><tr><td>73<td><span>    </span><span style=color:#62a35c>drop</span><span>(handle_tx);
</span><tr><td>74<td><span>
</span><tr><td>75<td><span>    </span><span style=color:#a71d5d;font-weight:700>let</span><span> start_time </span><span style=color:#a71d5d;font-weight:700>= </span><span>Instant</span><span style=color:#a71d5d;font-weight:700>::</span><span>now();
</span><tr><td>76<td><span>    </span><span style=color:#969896;font-style:italic>// Receive the handle from the next thread that finishes.
</span><tr><td>77<td><span>    </span><span style=color:#a71d5d;font-weight:700>while let </span><span style=color:#0086b3>Ok</span><span>(handle) </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle_rx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>recv</span><span>() {
</span><tr><td>78<td><span>        </span><span style=color:#969896;font-style:italic>// Join the thread and get the result.
</span><tr><td>79<td><span>        </span><span style=color:#a71d5d;font-weight:700>match</span><span> handle</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>join</span><span>() {
</span><tr><td>80<td><span>            </span><span style=color:#0086b3>Ok</span><span>(sleep_duration) </span><span style=color:#a71d5d;font-weight:700>=> </span><span>{
</span><tr><td>81<td><span>                </span><span style=color:#a71d5d;font-weight:700>let</span><span> time_elapsed </span><span style=color:#a71d5d;font-weight:700>=</span><span> start_time</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>elapsed</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>as_secs_f64</span><span>();
</span><tr><td>82<td><span>                println!(</span><span style=color:#183691>"</span><span style=color:#0086b3>{time_elapsed:.2}</span><span style=color:#183691>: Thread finished: slept for </span><span style=color:#0086b3>{sleep_duration}</span><span style=color:#183691> seconds."</span><span>);
</span><tr><td>83<td><span>            }
</span><tr><td>84<td><span>            </span><span style=color:#0086b3>Err</span><span>(e) </span><span style=color:#a71d5d;font-weight:700>=> </span><span>eprintln!(</span><span style=color:#183691>"Error joining thread: </span><span style=color:#0086b3>{e:?}</span><span style=color:#183691>"</span><span>),
</span><tr><td>85<td><span>        }
</span><tr><td>86<td><span>    }
</span><tr><td>87<td><span>}
</span><tr><td>88<td><span>
</span><tr><td>89<td><span>#[cfg(test)]
</span><tr><td>90<td><span style=color:#a71d5d;font-weight:700>mod </span><span>tests {
</span><tr><td>91<td><span>    </span><span style=color:#a71d5d;font-weight:700>use super::*</span><span>;
</span><tr><td>92<td><span>
</span><tr><td>93<td><span>    </span><span style=color:#a71d5d;font-weight:700>mod </span><span>spawn_self_shipping_thread {
</span><tr><td>94<td><span>        </span><span style=color:#a71d5d;font-weight:700>use super::*</span><span>;
</span><tr><td>95<td><span>
</span><tr><td>96<td><span>        #[test]
</span><tr><td>97<td><span>        </span><span style=color:#a71d5d;font-weight:700>fn </span><span style=color:#795da3;font-weight:700>handles_panic</span><span>() {
</span><tr><td>98<td><span>            </span><span style=color:#969896;font-style:italic>// Create the channel.
</span><tr><td>99<td><span>            </span><span style=color:#a71d5d;font-weight:700>let </span><span>(tx, rx) </span><span style=color:#a71d5d;font-weight:700>= </span><span>mpsc</span><span style=color:#a71d5d;font-weight:700>::</span><span>channel();
</span><tr><td>100<td><span>
</span><tr><td>101<td><span>            </span><span style=color:#969896;font-style:italic>// Spawn the self-shipping thread. Make it panic.
</span><tr><td>102<td><span>            </span><span style=color:#62a35c>spawn_self_shipping_thread</span><span>(tx, || {
</span><tr><td>103<td><span>                panic!(</span><span style=color:#183691>"Thread is panicking on purpose for testing"</span><span>);
</span><tr><td>104<td><span>            });
</span><tr><td>105<td><span>
</span><tr><td>106<td><span>            </span><span style=color:#969896;font-style:italic>// Ensure something was sent over the channel.
</span><tr><td>107<td><span>            </span><span style=color:#a71d5d;font-weight:700>let</span><span> handle </span><span style=color:#a71d5d;font-weight:700>=</span><span> rx</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>recv</span><span>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>108<td><span>            </span><span style=color:#969896;font-style:italic>// Join the self-shipping thread.
</span><tr><td>109<td><span>            </span><span style=color:#a71d5d;font-weight:700>let</span><span> join_result </span><span style=color:#a71d5d;font-weight:700>=</span><span> handle</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>join</span><span>();
</span><tr><td>110<td><span>            </span><span style=color:#969896;font-style:italic>// And see that it errored with our custom panic message.
</span><tr><td>111<td><span>            </span><span style=color:#a71d5d;font-weight:700>let</span><span> err </span><span style=color:#a71d5d;font-weight:700>=</span><span> join_result</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap_err</span><span>();
</span><tr><td>112<td><span>            </span><span style=color:#a71d5d;font-weight:700>let</span><span> panic_msg </span><span style=color:#a71d5d;font-weight:700>=</span><span> err</span><span style=color:#a71d5d;font-weight:700>.</span><span>downcast_ref</span><span style=color:#a71d5d;font-weight:700>::</span><span><</span><span style=color:#a71d5d;font-weight:700>&str</span><span>>()</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>unwrap</span><span>();
</span><tr><td>113<td><span>            assert!(panic_msg</span><span style=color:#a71d5d;font-weight:700>.</span><span style=color:#62a35c>contains</span><span>(</span><span style=color:#183691>"Thread is panicking on purpose for testing"</span><span>));
</span><tr><td>114<td><span>        }
</span><tr><td>115<td><span>    }
</span><tr><td>116<td><span>}
</span></table></code></pre></div></div></div><div class="row posts-page-navigation posts-page-navigation-bottom"><div class=col-6></div><div class=col-6></div></div></div></div></div><script crossorigin integrity=sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js></script><script>document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('pre[data-name]').forEach(function(preElement) {
                const fileName = preElement.getAttribute('data-name');
                const textContent = "Source: " + fileName;

                const fileNameElementPrepend = document.createElement('p');
                fileNameElementPrepend.className = 'filename';
                const linkPrepend = document.createElement('a');
                linkPrepend.href = fileName;
                linkPrepend.textContent = textContent;
                fileNameElementPrepend.appendChild(linkPrepend);
                preElement.prepend(fileNameElementPrepend);

                const fileNameElementAppend = document.createElement('p');
                fileNameElementAppend.className = 'filename';
                const linkAppend = document.createElement('a');
                linkAppend.href = fileName;
                linkAppend.textContent = textContent;
                fileNameElementAppend.appendChild(linkAppend);
                preElement.append(fileNameElementAppend);
            });
        });</script><script data-cf-beacon='{"token": "ad1cb2b3b9ce401a8877b99ffd513a0d"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script>