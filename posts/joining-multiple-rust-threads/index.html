<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/x-icon" href="/static/img/favicon.ico"><title>Joining threads immediately as they finish in Rust - João Sampaio - Software Engineer</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&amp;family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous"><link rel="stylesheet" href="/static/css/base.css"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="https://jpmelos.com/atom.xml"></head><body><div class="container"><div class="row row-site-title"><div class="col-12"><p><a href="https://jpmelos.com" class="site-title">João Sampaio's Blog</a></p></div></div><div class="row row-top-links"><div class="col-6"><p><a href="https://jpmelos.com">Home</a> <a href="https://jpmelos.com/posts/">Posts</a></p></div><div class="col-6 row-top-links-right"><p><a href="https://jpmelos.com/atom.xml" target="_blank">Feed↗</a> <a href="https://jpmelos.com/resume/" target="_blank">Resume↗</a></p></div></div><div class="row"><div class="col-12 content"><div class="row posts-page-navigation posts-page-navigation-top"><div class="col-6"></div><div class="col-6"></div></div><div class="row"><div class="col-12"><div class="posts-page-content"><h1>Joining threads immediately as they finish in Rust</h1><p class="posts-page-metadata">2025-05-15</p><ol><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#what-is-the-problem">What is the problem?</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#how-does-it-work-in-python">How does it work in Python?</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#doing-the-same-thing-in-rust">Doing the same thing in Rust</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#self-shipping-threads-in-rust">“Self-shipping” threads in Rust</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#but-what-if-the-thread-panics">But what if the thread panics?</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#exploring-an-alternative-approach">Exploring an alternative approach</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#conclusion">Conclusion</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#appendix-a">Appendix A: Does it work with regular threads too?</a></li></ol><h2 id="what-is-the-problem">What is the problem?</h2><p>As of Rust 1.87.0, if you want to join multiple threads using exclusively the standard library, joining them immediately as they finish (in case the order in which they finish is not deterministic) is not a straightforward task.</p><p>This post isn’t intended as criticism of Rust’s standard library. The absence of this feature may be an intentional design decision or simply a matter of priorities. Regardless, since joining threads is a common need, I’ll document my solution for future reference.</p><p>When you spawn threads, you get back a <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"><code>JoinHandle</code></a> (this is true for <a href="https://doc.rust-lang.org/std/thread/index.html">regular</a> and <a href="https://doc.rust-lang.org/std/thread/fn.scope.html">scoped threads</a>, and they are equivalent for the purposes of this post, see <a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#appendix-a">Appendix A</a>). Then, you can decide to join on those threads, or not:</p><ol><li>If you decide not to join those threads and just let them run unattended, you can just let the <code>JoinHandle</code> drop and the threads will be automatically dealt with when they’re done running. The threads are called “detached”, and you won’t have a way to know when they have completed or otherwise terminated.</li><li>If you decide to join the threads, you’ll need to call <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>JoinHandle::join</code></a> to join each of those threads individually. The problem is that <code>JoinHandle::join</code> blocks until the thread is finished. If you spawn multiple threads, which happens more often than not, there’s no way to wait on all of them simultaneously, and process each of them immediately as they finish.</li></ol><h2 id="how-does-it-work-in-python">How does it work in Python?</h2><p>Let’s see how it can be done in another language, and then try to achieve something similar in Rust.</p><p>In Python, there is the <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor"><code>ThreadPoolExecutor</code></a>. As you spawn threads using <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit"><code>ThreadPoolExecutor.submit</code></a>, you get <a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects"><code>Future</code></a>s back, which you can store in an iterable. You can pass that iterable into the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed"><code>concurrent.futures.as_completed</code></a> function, and it will yield those futures as they finish. You can process each future individually right then and there, and then immediately start waiting for the next one to finish.</p><pre data-linenos="" data-lang="python" data-name="python_threads_with_threadpool.py" style="background-color:#f1f1f1;color:#323232" class="language-python"><p class="filename"><a href="python_threads_with_threadpool.py">Source: python_threads_with_threadpool.py</a></p><code class="language-python" data-lang="python" data-name="python_threads_with_threadpool.py"><table><tbody><tr><td>1</td><td><span style="font-weight:700;color:#a71d5d">import </span><span>concurrent</span><span style="font-weight:700;color:#a71d5d">.</span><span>futures
</span></td></tr><tr><td>2</td><td><span style="font-weight:700;color:#a71d5d">import </span><span>time
</span></td></tr><tr><td>3</td><td><span style="font-weight:700;color:#a71d5d">from </span><span>concurrent</span><span style="font-weight:700;color:#a71d5d">.</span><span>futures </span><span style="font-weight:700;color:#a71d5d">import </span><span>ThreadPoolExecutor
</span></td></tr><tr><td>4</td><td><span>
</span></td></tr><tr><td>5</td><td><span>
</span></td></tr><tr><td>6</td><td><span style="font-style:italic;color:#969896"># I'll call this function from my threads.
</span></td></tr><tr><td>7</td><td><span style="font-weight:700;color:#a71d5d">def </span><span style="font-weight:700;color:#323232">target_fn</span><span>(sleep_duration: </span><span style="color:#0086b3">int</span><span>) -&gt; </span><span style="color:#0086b3">int</span><span>:
</span></td></tr><tr><td>8</td><td><span>    </span><span style="color:#62a35c">print</span><span>(</span><span style="font-weight:700;color:#a71d5d">f</span><span style="color:#183691">"Sleeping for </span><span>{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>)
</span></td></tr><tr><td>9</td><td><span>    time</span><span style="font-weight:700;color:#a71d5d">.</span><span>sleep(sleep_duration)
</span></td></tr><tr><td>10</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">return </span><span>sleep_duration
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>
</span></td></tr><tr><td>13</td><td><span>start_time </span><span style="font-weight:700;color:#a71d5d">= </span><span>time</span><span style="font-weight:700;color:#a71d5d">.</span><span>monotonic()
</span></td></tr><tr><td><mark style="background-color:#efefb8">14</mark></td><td><mark style="background-color:#efefb8"><span style="font-style:italic;color:#969896"># Using `ThreadPoolExecutor` as a context manager guarantees that all threads
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">15</mark></td><td><mark style="background-color:#efefb8"><span style="font-style:italic;color:#969896"># will be joined before the context manager's scope ends. This is very similar
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">16</mark></td><td><mark style="background-color:#efefb8"><span style="font-style:italic;color:#969896"># to Rust's scoped threads.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">17</mark></td><td><mark style="background-color:#efefb8"><span style="font-weight:700;color:#a71d5d">with </span><span>ThreadPoolExecutor() </span><span style="font-weight:700;color:#a71d5d">as </span><span>executor:
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">18</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896"># Collect the futures into a set.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">19</mark></td><td><mark style="background-color:#efefb8"><span>    futures </span><span style="font-weight:700;color:#a71d5d">= </span><span>{
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">20</mark></td><td><mark style="background-color:#efefb8"><span>        executor</span><span style="font-weight:700;color:#a71d5d">.</span><span>submit(target_fn, </span><span style="color:#0086b3">5</span><span>),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">21</mark></td><td><mark style="background-color:#efefb8"><span>        executor</span><span style="font-weight:700;color:#a71d5d">.</span><span>submit(target_fn, </span><span style="color:#0086b3">3</span><span>),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">22</mark></td><td><mark style="background-color:#efefb8"><span>        executor</span><span style="font-weight:700;color:#a71d5d">.</span><span>submit(target_fn, </span><span style="color:#0086b3">1</span><span>),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">23</mark></td><td><mark style="background-color:#efefb8"><span>    }
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">24</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896"># Get the futures as they finish using `as_completed`.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">25</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-weight:700;color:#a71d5d">for </span><span>future </span><span style="font-weight:700;color:#a71d5d">in </span><span>concurrent</span><span style="font-weight:700;color:#a71d5d">.</span><span>futures</span><span style="font-weight:700;color:#a71d5d">.</span><span>as_completed(futures):
</span></mark></td></tr><tr><td>26</td><td><span>        time_elapsed </span><span style="font-weight:700;color:#a71d5d">= </span><span>time</span><span style="font-weight:700;color:#a71d5d">.</span><span>monotonic() </span><span style="font-weight:700;color:#a71d5d">- </span><span>start_time
</span></td></tr><tr><td>27</td><td><span>        return_value </span><span style="font-weight:700;color:#a71d5d">= </span><span>future</span><span style="font-weight:700;color:#a71d5d">.</span><span>result()
</span></td></tr><tr><td>28</td><td><span>        </span><span style="color:#62a35c">print</span><span>(
</span></td></tr><tr><td>29</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">f</span><span style="color:#183691">"</span><span>{time_elapsed</span><span style="color:#0086b3">:.2f</span><span>}</span><span style="color:#183691">:"
</span></td></tr><tr><td>30</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">f</span><span style="color:#183691">" Thread finished:"
</span></td></tr><tr><td>31</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">f</span><span style="color:#183691">" slept for </span><span>{return_value}</span><span style="color:#183691"> seconds."
</span></td></tr><tr><td>32</td><td><span>        )
</span></td></tr></tbody></table></code><p class="filename"><a href="python_threads_with_threadpool.py">Source: python_threads_with_threadpool.py</a></p></pre><p>Running the code above with Python 3.13.2 yields this (with some variation regarding the timestamps):</p><pre style="background-color:#f1f1f1;color:#323232"><code><span>Sleeping for 5 seconds.
</span><span>Sleeping for 3 seconds.
</span><span>Sleeping for 1 seconds.
</span><span>1.00: Thread finished: slept for 1 seconds.
</span><span>3.01: Thread finished: slept for 3 seconds.
</span><span>5.01: Thread finished: slept for 5 seconds.
</span></code></pre><p>You can tell from the timestamps in the last few lines that each thread was processed as soon as it finished.</p><h2 id="doing-the-same-thing-in-rust">Doing the same thing in Rust</h2><p>There’s nothing like <code>concurrent.futures.as_completed</code> in Rust’s standard library. <code>JoinHandle::join</code> will block until each thread finishes, you’ll need to call it once for each thread, and you don’t know when each thread will finish.</p><p>The method <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.is_finished"><code>JoinHandle::is_finished</code></a> can be used to check whether a thread has already finished, and it will always return immediately with a boolean. Therefore, it is possible to use it with a looping sleep to keep watch for when threads finish. But you can’t make it happen without that loop.</p><p>Now, all that said, I’m sure this is a solved problem. There must be a crate somewhere that solves this exact problem in an elegant and performant way. But I decided to tackle this problem myself as an opportunity to deepen my understanding of Rust’s threading model.</p><p>First, I’ll implement a Rust program that manages several threads using the looping approach:</p><pre data-linenos="" data-lang="rust" data-name="rust_threads_with_looping_sleep.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_threads_with_looping_sleep.rs">Source: rust_threads_with_looping_sleep.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_threads_with_looping_sleep.rs"><table><tbody><tr><td>1</td><td><span style="font-weight:700;color:#a71d5d">use </span><span>std</span><span style="font-weight:700;color:#a71d5d">::</span><span>thread;
</span></td></tr><tr><td>2</td><td><span style="font-weight:700;color:#a71d5d">use </span><span>std</span><span style="font-weight:700;color:#a71d5d">::</span><span>time</span><span style="font-weight:700;color:#a71d5d">::</span><span>{Duration, Instant};
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span style="font-style:italic;color:#969896">// I'll call this function from my threads.
</span></td></tr><tr><td>5</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">target_fn</span><span>(sleep_duration: </span><span style="font-weight:700;color:#a71d5d">u64</span><span>) -&gt; </span><span style="font-weight:700;color:#a71d5d">u64 </span><span>{
</span></td></tr><tr><td>6</td><td><span>    println!(</span><span style="color:#183691">"Sleeping for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>7</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>sleep(Duration</span><span style="font-weight:700;color:#a71d5d">::</span><span>from_secs(sleep_duration));
</span></td></tr><tr><td>8</td><td><span>    sleep_duration
</span></td></tr><tr><td>9</td><td><span>}
</span></td></tr><tr><td>10</td><td><span>
</span></td></tr><tr><td>11</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">main</span><span>() {
</span></td></tr><tr><td><mark style="background-color:#efefb8">12</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896">// Spawn the threads and put all the handles in a vector.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">13</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-weight:700;color:#a71d5d">let mut</span><span> handles </span><span style="font-weight:700;color:#a71d5d">= </span><span>vec![
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">14</mark></td><td><mark style="background-color:#efefb8"><span>        thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>spawn(|| </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">5</span><span>)),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">15</mark></td><td><mark style="background-color:#efefb8"><span>        thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>spawn(|| </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">3</span><span>)),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">16</mark></td><td><mark style="background-color:#efefb8"><span>        thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>spawn(|| </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">1</span><span>)),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">17</mark></td><td><mark style="background-color:#efefb8"><span>    ];
</span></mark></td></tr><tr><td>18</td><td><span>
</span></td></tr><tr><td>19</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">let</span><span> start_time </span><span style="font-weight:700;color:#a71d5d">= </span><span>Instant</span><span style="font-weight:700;color:#a71d5d">::</span><span>now();
</span></td></tr><tr><td>20</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">while !</span><span>handles</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">is_empty</span><span>() {
</span></td></tr><tr><td>21</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let mut</span><span> i </span><span style="font-weight:700;color:#a71d5d">= </span><span style="color:#0086b3">0</span><span>;
</span></td></tr><tr><td>22</td><td><span>
</span></td></tr><tr><td>23</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">while</span><span> i </span><span style="font-weight:700;color:#a71d5d">&lt;</span><span> handles</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">len</span><span>() {
</span></td></tr><tr><td><mark style="background-color:#efefb8">24</mark></td><td><mark style="background-color:#efefb8"><span>            </span><span style="font-style:italic;color:#969896">// Call `JoinHandle.is_finished` for each thread, until one of them is.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">25</mark></td><td><mark style="background-color:#efefb8"><span>            </span><span style="font-weight:700;color:#a71d5d">if</span><span> handles[i]</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">is_finished</span><span>() {
</span></mark></td></tr><tr><td>26</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> handles</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">remove</span><span>(i);
</span></td></tr><tr><td><mark style="background-color:#efefb8">27</mark></td><td><mark style="background-color:#efefb8"><span>                </span><span style="font-style:italic;color:#969896">// Call `JoinHandle.join`, get the result, print it.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">28</mark></td><td><mark style="background-color:#efefb8"><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> sleep_duration </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">join</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td>29</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> time_elapsed </span><span style="font-weight:700;color:#a71d5d">=</span><span> start_time</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">elapsed</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">as_secs_f64</span><span>();
</span></td></tr><tr><td>30</td><td><span>                println!(</span><span style="color:#183691">"</span><span style="color:#0086b3">{time_elapsed:.2}</span><span style="color:#183691">: Thread finished: slept for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>31</td><td><span>            } </span><span style="font-weight:700;color:#a71d5d">else </span><span>{
</span></td></tr><tr><td>32</td><td><span>                i </span><span style="font-weight:700;color:#a71d5d">+= </span><span style="color:#0086b3">1</span><span>;
</span></td></tr><tr><td>33</td><td><span>            }
</span></td></tr><tr><td>34</td><td><span>        }
</span></td></tr><tr><td>35</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">36</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Sleep, the main thread yields control so the others can continue.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">37</mark></td><td><mark style="background-color:#efefb8"><span>        thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>sleep(Duration</span><span style="font-weight:700;color:#a71d5d">::</span><span>from_millis(</span><span style="color:#0086b3">10</span><span>));
</span></mark></td></tr><tr><td>38</td><td><span>    }
</span></td></tr><tr><td>39</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_threads_with_looping_sleep.rs">Source: rust_threads_with_looping_sleep.rs</a></p></pre><p>Here’s the output from that program:</p><pre style="background-color:#f1f1f1;color:#323232"><code><span>Sleeping for 5 seconds.
</span><span>Sleeping for 1 seconds.
</span><span>Sleeping for 3 seconds.
</span><span>1.00: Thread finished: slept for 1 seconds.
</span><span>3.00: Thread finished: slept for 3 seconds.
</span><span>5.01: Thread finished: slept for 5 seconds.
</span></code></pre><p>That’s not terrible, but what if you don’t want to loop? I encountered this problem when writing <a href="https://github.com/jpmelos/fdintercept"><code>fdintercept</code></a>.</p><h2 id="self-shipping-threads-in-rust">“Self-shipping” threads in Rust</h2><p>The solution that I found in Rust is this: let each spawned thread communicate to the parent thread when it has finished. This can be done via regular <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc</code> channels</a>, and thus the parent thread just needs to wait for something to arrive over the channel instead of looping.</p><p>First, I wrote a function that spawns a new thread inside an existing thread scope, but this is a special thread: it will send its own handle to the parent thread. In my code, I call it a “self-shipping thread”. The function also receives the target function that we want to run in the new thread.</p><p>Let’s see how this function is implemented below, and then we’ll go through it step by step.</p><pre data-linenos="" data-lang="rust" data-name="rust_self_shipping_threads_naive.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_self_shipping_threads_naive.rs"><table><tbody><tr><td>7</td><td><span style="font-weight:700;color:#a71d5d">pub fn </span><span style="font-weight:700;color:#795da3">spawn_self_shipping_thread_in_scope</span><span>&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, F, R&gt;(
</span></td></tr><tr><td>8</td><td><span>    scope: </span><span style="font-weight:700;color:#a71d5d">&amp;'scope </span><span>thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>Scope&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, '</span><span style="font-weight:700;color:#a71d5d">_</span><span>&gt;,
</span></td></tr><tr><td><mark style="background-color:#efefb8">9</mark></td><td><mark style="background-color:#efefb8"><span>    tx: mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>Sender&lt;ScopedJoinHandle&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, R&gt;&gt;,
</span></mark></td></tr><tr><td>10</td><td><span>    func: F,
</span></td></tr><tr><td>11</td><td><span>) </span><span style="font-weight:700;color:#a71d5d">where
</span></td></tr><tr><td>12</td><td><span>    F: FnOnce() -&gt; R + Send + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></td></tr><tr><td>13</td><td><span>    R: Send + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></td></tr><tr><td>14</td><td><span>{
</span></td></tr><tr><td><mark style="background-color:#efefb8">15</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896">// Create the channel that will be used to transfer the new thread's handle from the parent
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">16</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896">// thread to the new thread.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">17</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-weight:700;color:#a71d5d">let </span><span>(handle_tx, handle_rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></mark></td></tr><tr><td>18</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">19</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896">// Spawn the new thread in the scope.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">20</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> scope</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">spawn</span><span>(</span><span style="font-weight:700;color:#a71d5d">move || </span><span>{
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">21</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Execute the target function.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">22</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> result </span><span style="font-weight:700;color:#a71d5d">= </span><span style="color:#62a35c">func</span><span>();
</span></mark></td></tr><tr><td>23</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">24</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Receive the handler that was sent by the parent thread to the new thread via the
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">25</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// channel.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">26</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle_rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">27</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// And immediately send it to the caller of `spawn_self_shipping_thread_in_scope`. It is
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">28</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// responsibility of the caller to make sure that the `rx` side of this channel is alive
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">29</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// until after this thread is finished.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">30</mark></td><td><mark style="background-color:#efefb8"><span>        tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(handle)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td>31</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">32</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Return the same result as the target function.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">33</mark></td><td><mark style="background-color:#efefb8"><span>        result
</span></mark></td></tr><tr><td>34</td><td><span>    });
</span></td></tr><tr><td>35</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">36</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896">// Send the new thread's handle into the new thread itself.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">37</mark></td><td><mark style="background-color:#efefb8"><span>    handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(handle)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td>38</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p></pre><p>The function receives three things: the thread scope in which the new threads will be created, the channel’s sending end which will be used the send the thread handle to the caller of <code>spawn_self_shipping_thread_in_scope</code>, and the target function we want to run in the new thread.</p><p>The function uses two channels:</p><ol><li>From parent thread to new thread: sends the handle to the new thread (created in line 17, used in lines 26 and 37).</li><li>From new thread to caller: returns the handle when the thread is finished (received from the caller in line 9, used in line 30).</li></ol><p>The parent thread creates the first channel, spawns the new thread, and sends the handle to it. Meanwhile, the new thread executes the target function, receives its own handle via the first channel, and sends it back to the caller through the second channel before returning the function’s result.</p><p>This is how <code>spawn_self_shipping_thread_in_scope</code> can be used:</p><pre data-linenos="" data-lang="rust" data-name="rust_self_shipping_threads_naive.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_self_shipping_threads_naive.rs"><table><tbody><tr><td>40</td><td><span style="font-style:italic;color:#969896">// I'll call this function from my threads.
</span></td></tr><tr><td>41</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">target_fn</span><span>(sleep_duration: </span><span style="font-weight:700;color:#a71d5d">u64</span><span>) -&gt; </span><span style="font-weight:700;color:#a71d5d">u64 </span><span>{
</span></td></tr><tr><td>42</td><td><span>    println!(</span><span style="color:#183691">"Sleeping for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>43</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>sleep(Duration</span><span style="font-weight:700;color:#a71d5d">::</span><span>from_secs(sleep_duration));
</span></td></tr><tr><td>44</td><td><span>    sleep_duration
</span></td></tr><tr><td>45</td><td><span>}
</span></td></tr><tr><td>46</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">47</mark></td><td><mark style="background-color:#efefb8"><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">main</span><span>() {
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">48</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896">// Create the thread scope.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">49</mark></td><td><mark style="background-color:#efefb8"><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>scope(</span><span style="font-weight:700;color:#a71d5d">move |</span><span>scope</span><span style="font-weight:700;color:#a71d5d">| </span><span>{
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">50</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Create the channel that the new threads will use to send their handles to the main
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">51</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// thread.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">52</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-weight:700;color:#a71d5d">let </span><span>(handle_tx, handle_rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></mark></td></tr><tr><td>53</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">54</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Spawn the new threads.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">55</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="color:#62a35c">spawn_self_shipping_thread_in_scope</span><span>(scope, handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">1</span><span>));
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">56</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="color:#62a35c">spawn_self_shipping_thread_in_scope</span><span>(scope, handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">3</span><span>));
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">57</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="color:#62a35c">spawn_self_shipping_thread_in_scope</span><span>(scope, handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">5</span><span>));
</span></mark></td></tr><tr><td>58</td><td><span>
</span></td></tr><tr><td>59</td><td><span>        </span><span style="font-style:italic;color:#969896">// Drop this `handle_tx` so that when all the threads are finished and all the `handle_tx`
</span></td></tr><tr><td>60</td><td><span>        </span><span style="font-style:italic;color:#969896">// clones are dropped, `handle_rx` will return `Err`.
</span></td></tr><tr><td>61</td><td><span>        </span><span style="color:#62a35c">drop</span><span>(handle_tx);
</span></td></tr><tr><td>62</td><td><span>
</span></td></tr><tr><td>63</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> start_time </span><span style="font-weight:700;color:#a71d5d">= </span><span>Instant</span><span style="font-weight:700;color:#a71d5d">::</span><span>now();
</span></td></tr><tr><td><mark style="background-color:#efefb8">64</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Receive the handle from the next thread that finishes.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">65</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-weight:700;color:#a71d5d">while let </span><span style="color:#0086b3">Ok</span><span>(handle) </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle_rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>() {
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">66</mark></td><td><mark style="background-color:#efefb8"><span>            </span><span style="font-style:italic;color:#969896">// Join the thread and get the result.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">67</mark></td><td><mark style="background-color:#efefb8"><span>            </span><span style="font-weight:700;color:#a71d5d">match</span><span> handle</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">join</span><span>() {
</span></mark></td></tr><tr><td>68</td><td><span>                </span><span style="color:#0086b3">Ok</span><span>(sleep_duration) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>{
</span></td></tr><tr><td>69</td><td><span>                    </span><span style="font-weight:700;color:#a71d5d">let</span><span> time_elapsed </span><span style="font-weight:700;color:#a71d5d">=</span><span> start_time</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">elapsed</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">as_secs_f64</span><span>();
</span></td></tr><tr><td>70</td><td><span>                    println!(
</span></td></tr><tr><td>71</td><td><span>                        </span><span style="color:#183691">"</span><span style="color:#0086b3">{time_elapsed:.2}</span><span style="color:#183691">: Thread finished: slept for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."
</span></td></tr><tr><td>72</td><td><span>                    );
</span></td></tr><tr><td>73</td><td><span>                }
</span></td></tr><tr><td>74</td><td><span>                </span><span style="color:#0086b3">Err</span><span>(e) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>eprintln!(</span><span style="color:#183691">"Error joining thread: </span><span style="color:#0086b3">{e:?}</span><span style="color:#183691">"</span><span>),
</span></td></tr><tr><td>75</td><td><span>            }
</span></td></tr><tr><td>76</td><td><span>        }
</span></td></tr><tr><td>77</td><td><span>    });
</span></td></tr><tr><td>78</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p></pre><p>When spawning the threads, you need to create the scope and the channel, spawn the threads by calling <code>spawn_self_shipping_thread_in_scope</code> while passing the scope, the <code>handle_tx</code> side of the channel, and the target function, and then just wait on the <code>handle_rx</code> side for the handles. As handles arrive, it is guaranteed that their threads have completed.</p><p>This is the result:</p><pre style="background-color:#f1f1f1;color:#323232"><code><span>Sleeping for 1 seconds.
</span><span>Sleeping for 3 seconds.
</span><span>Sleeping for 5 seconds.
</span><span>1.01: Thread finished: slept for 1 seconds.
</span><span>3.00: Thread finished: slept for 3 seconds.
</span><span>5.00: Thread finished: slept for 5 seconds.
</span></code></pre><h2 id="but-what-if-the-thread-panics">But what if the thread panics?</h2><p>But the code above has a fatal flaw: what if the thread panics? Then, it won’t send the handle to the parent thread. Although the thread will eventually be joined when the scope ends, it will bypass our custom processing logic.</p><p>Let’s fix that.</p><p>First, let’s write a test that proves that we have a problem and that we can later use to prove that we have fixed the issue.</p><pre data-linenos="" data-lang="rust" data-name="rust_self_shipping_threads_naive.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_self_shipping_threads_naive.rs"><table><tbody><tr><td>87</td><td><span>        #[test]
</span></td></tr><tr><td>88</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">handles_panic</span><span>() {
</span></td></tr><tr><td>89</td><td><span>            </span><span style="font-style:italic;color:#969896">// Create the thread scope.
</span></td></tr><tr><td>90</td><td><span>            thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>scope(|scope| {
</span></td></tr><tr><td>91</td><td><span>                </span><span style="font-style:italic;color:#969896">// And the channel.
</span></td></tr><tr><td>92</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let </span><span>(tx, rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></td></tr><tr><td>93</td><td><span>
</span></td></tr><tr><td>94</td><td><span>                </span><span style="font-style:italic;color:#969896">// Spawn the self-shipping thread. Make it panic.
</span></td></tr><tr><td>95</td><td><span>                </span><span style="color:#62a35c">spawn_self_shipping_thread_in_scope</span><span>(scope, tx, || {
</span></td></tr><tr><td>96</td><td><span>                    panic!(</span><span style="color:#183691">"Thread is panicking on purpose for testing"</span><span>);
</span></td></tr><tr><td>97</td><td><span>                });
</span></td></tr><tr><td>98</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">99</mark></td><td><mark style="background-color:#efefb8"><span>                </span><span style="font-style:italic;color:#969896">// Ensure something was sent over the channel.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">100</mark></td><td><mark style="background-color:#efefb8"><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td>101</td><td><span>                </span><span style="font-style:italic;color:#969896">// Join the self-shipping thread.
</span></td></tr><tr><td>102</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> join_result </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">join</span><span>();
</span></td></tr><tr><td>103</td><td><span>                </span><span style="font-style:italic;color:#969896">// And see that it errored with our custom panic message.
</span></td></tr><tr><td>104</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> err </span><span style="font-weight:700;color:#a71d5d">=</span><span> join_result</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap_err</span><span>();
</span></td></tr><tr><td>105</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> panic_msg </span><span style="font-weight:700;color:#a71d5d">=</span><span> err</span><span style="font-weight:700;color:#a71d5d">.</span><span>downcast_ref</span><span style="font-weight:700;color:#a71d5d">::</span><span>&lt;</span><span style="font-weight:700;color:#a71d5d">&amp;str</span><span>&gt;()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>106</td><td><span>                assert!(panic_msg</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">contains</span><span>(</span><span style="color:#183691">"Thread is panicking on purpose for testing"</span><span>));
</span></td></tr><tr><td>107</td><td><span>            });
</span></td></tr><tr><td>108</td><td><span>        }
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p></pre><p>Running the test, this is what we get:</p><pre style="background-color:#f1f1f1;color:#323232"><code><span>thread 'tests::spawn_self_shipping_thread_in_scope::handles_panic' panicked at src/main.rs:98:40:
</span><span>called `Result::unwrap()` on an `Err` value: RecvError
</span></code></pre><p>The error comes from line 100: since nothing was ever sent into the channel before it was closed, calling <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>recv</code></a> on it causes it to return an <code>Err</code>.</p><p>So, how do we make the test pass?</p><p>The idea here is this: no matter what happens, we always want the thread handle to be sent to the caller of <code>spawn_self_shipping_thread_in_scope</code>, even if the thread panics.</p><p>When a Rust thread panics, it goes through a process called <a href="https://doc.rust-lang.org/nomicon/unwinding.html">“unwinding”</a>. During this process, everything in the thread stack is dropped as usual. <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> implementations are still respected after panics! So we need to implement something that, when dropped, will send the handle through the channel.</p><p>What would such a thing look like? Let’s take a look.</p><pre data-linenos="" data-lang="rust" data-name="rust_self_shipping_threads.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_self_shipping_threads.rs"><table><tbody><tr><td>7</td><td><span style="font-style:italic;color:#969896">// A struct with a `Drop` implementation to ensure the thread handle is sent to the caller of
</span></td></tr><tr><td>8</td><td><span style="font-style:italic;color:#969896">// `spawn_self_shipping_thread_in_scope` even if the self-shipping thread panics.
</span></td></tr><tr><td>9</td><td><span style="font-weight:700;color:#a71d5d">struct </span><span>SendOnDrop&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, R&gt; {
</span></td></tr><tr><td>10</td><td><span>    handle: </span><span style="color:#0086b3">Option</span><span>&lt;ScopedJoinHandle&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, R&gt;&gt;,
</span></td></tr><tr><td>11</td><td><span>    tx: mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>Sender&lt;ScopedJoinHandle&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, R&gt;&gt;,
</span></td></tr><tr><td>12</td><td><span>}
</span></td></tr><tr><td>13</td><td><span>
</span></td></tr><tr><td>14</td><td><span style="font-weight:700;color:#a71d5d">impl</span><span>&lt;R&gt; Drop </span><span style="font-weight:700;color:#a71d5d">for </span><span>SendOnDrop&lt;'</span><span style="font-weight:700;color:#a71d5d">_</span><span>, R&gt; {
</span></td></tr><tr><td>15</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">drop</span><span>(</span><span style="font-weight:700;color:#a71d5d">&amp;mut </span><span>self) {
</span></td></tr><tr><td>16</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">if let </span><span style="color:#0086b3">Some</span><span>(handle) </span><span style="font-weight:700;color:#a71d5d">= </span><span>self</span><span style="font-weight:700;color:#a71d5d">.</span><span>handle</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">take</span><span>() {
</span></td></tr><tr><td>17</td><td><span>            self</span><span style="font-weight:700;color:#a71d5d">.</span><span>tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(handle)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>18</td><td><span>        }
</span></td></tr><tr><td>19</td><td><span>    }
</span></td></tr><tr><td>20</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p></pre><p>The struct <code>SendOnDrop</code> is something that owns the thread handle and <code>tx</code> (the sending end of the channel created by the caller of <code>spawn_self_shipping_thread_in_scope</code>). It implements the <code>Drop</code> trait, which requires an implementation for the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>Drop::drop</code></a> method, and this is the method that runs when <code>SendOnDrop</code> is dropped.</p><p>The <code>Drop::drop</code> method will take ownership of the handle (that’s why its created as an <code>Option&lt;ScopedJoinHandle&lt;'scope, R&gt;&gt;</code> on the struct, so we can take ownership of it and leave a <code>None</code> in its place), and send it through the channel.</p><p>And here’s the version of <code>spawn_self_shipping_thread_in_scope</code> that makes use of the <code>SendOnDrop</code> struct:</p><pre data-linenos="" data-lang="rust" data-name="rust_self_shipping_threads.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_self_shipping_threads.rs"><table><tbody><tr><td>22</td><td><span style="font-weight:700;color:#a71d5d">pub fn </span><span style="font-weight:700;color:#795da3">spawn_self_shipping_thread_in_scope</span><span>&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, F, R&gt;(
</span></td></tr><tr><td>23</td><td><span>    scope: </span><span style="font-weight:700;color:#a71d5d">&amp;'scope </span><span>thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>Scope&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, '</span><span style="font-weight:700;color:#a71d5d">_</span><span>&gt;,
</span></td></tr><tr><td>24</td><td><span>    tx: mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>Sender&lt;ScopedJoinHandle&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, R&gt;&gt;,
</span></td></tr><tr><td>25</td><td><span>    func: F,
</span></td></tr><tr><td>26</td><td><span>) </span><span style="font-weight:700;color:#a71d5d">where
</span></td></tr><tr><td>27</td><td><span>    F: FnOnce() -&gt; R + Send + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></td></tr><tr><td>28</td><td><span>    R: Send + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></td></tr><tr><td>29</td><td><span>{
</span></td></tr><tr><td>30</td><td><span>    </span><span style="font-style:italic;color:#969896">// Create the channel that will be used to transfer the new thread's handle from the parent
</span></td></tr><tr><td>31</td><td><span>    </span><span style="font-style:italic;color:#969896">// thread to the new thread.
</span></td></tr><tr><td>32</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">let </span><span>(handle_tx, handle_rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></td></tr><tr><td>33</td><td><span>
</span></td></tr><tr><td>34</td><td><span>    </span><span style="font-style:italic;color:#969896">// Spawn the new thread in the scope.
</span></td></tr><tr><td>35</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> scope</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">spawn</span><span>(</span><span style="font-weight:700;color:#a71d5d">move || </span><span>{
</span></td></tr><tr><td>36</td><td><span>        </span><span style="font-style:italic;color:#969896">// Receive the handler that was sent by the parent thread to the new thread via the
</span></td></tr><tr><td>37</td><td><span>        </span><span style="font-style:italic;color:#969896">// channel.
</span></td></tr><tr><td>38</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle_rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>39</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">40</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// This will send the new thread's handle to the caller of
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">41</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// `spawn_self_shipping_thread_in_scope` when the thread stack is destroyed, even if that
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">42</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// happens due to a panic.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">43</mark></td><td><mark style="background-color:#efefb8"><span>        SendOnDrop {
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">44</mark></td><td><mark style="background-color:#efefb8"><span>            handle: </span><span style="color:#0086b3">Some</span><span>(handle),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">45</mark></td><td><mark style="background-color:#efefb8"><span>            </span><span style="font-style:italic;color:#969896">// It is responsibility of the caller to make sure that the `rx` side of this
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">46</mark></td><td><mark style="background-color:#efefb8"><span>            </span><span style="font-style:italic;color:#969896">// channel is alive until after this thread is finished.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">47</mark></td><td><mark style="background-color:#efefb8"><span>            tx,
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">48</mark></td><td><mark style="background-color:#efefb8"><span>        };
</span></mark></td></tr><tr><td>49</td><td><span>
</span></td></tr><tr><td>50</td><td><span>        </span><span style="font-style:italic;color:#969896">// Execute the target function and return its result.
</span></td></tr><tr><td>51</td><td><span>        </span><span style="color:#62a35c">func</span><span>()
</span></td></tr><tr><td>52</td><td><span>    });
</span></td></tr><tr><td>53</td><td><span>
</span></td></tr><tr><td>54</td><td><span>    </span><span style="font-style:italic;color:#969896">// Send the new thread's handle into the new thread itself.
</span></td></tr><tr><td>55</td><td><span>    handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(handle)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>56</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p></pre><p>The body of the self-shipping thread changed significantly: now, the first thing it does is get the handle from the parent thread. Then, it creates a <code>SendOnDrop</code> struct on the stack. We don’t even need to give it a name: as long as it is sitting on the stack, it will be properly dropped in the event of a panic, or when the thread finishes.</p><p>Then, we run the target function and return its result.</p><p>And now, if we run the test from before, it passes! We now have self-shipping threads that we can act on immediately when they return, and they will still notify the caller of <code>spawn_self_shipping_thread_in_scope</code> when they finish, even if that happens because of a panic.</p><h2 id="exploring-an-alternative-approach">Exploring an alternative approach</h2><p>Alternatively, if a timely result is needed from a thread, it’s fairly common to pass that result to the interested thread via a channel, instead of arranging for the thread handle to be passed around and waiting for it to finish. If your function will be passing values to the parent thread via a channel regardless, then this is probably more appropriate, since most of the code will be in place already.</p><p>Otherwise, if all you care about is the return value of the function that you want to run in a separate thread, then the additional complexity may not be worth it.</p><p>Here’s what an implementation<sup><a id="footnote_ref__simpler-threads-sending-results-implementation" href="#footnote__simpler-threads-sending-results-implementation">1</a></sup> of that approach looks like:</p><pre data-linenos="" data-lang="rust" data-name="rust_threads_sending_results.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_threads_sending_results.rs">Source: rust_threads_sending_results.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_threads_sending_results.rs"><table><tbody><tr><td>1</td><td><span style="font-weight:700;color:#a71d5d">use </span><span>std</span><span style="font-weight:700;color:#a71d5d">::</span><span>{
</span></td></tr><tr><td>2</td><td><span>    sync</span><span style="font-weight:700;color:#a71d5d">::</span><span>mpsc,
</span></td></tr><tr><td>3</td><td><span>    thread,
</span></td></tr><tr><td>4</td><td><span>    time</span><span style="font-weight:700;color:#a71d5d">::</span><span>{Duration, Instant},
</span></td></tr><tr><td>5</td><td><span>};
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">spawn_thread_in_scope</span><span>&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, F, R&gt;(
</span></td></tr><tr><td>8</td><td><span>    scope: </span><span style="font-weight:700;color:#a71d5d">&amp;'scope </span><span>thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>Scope&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, '</span><span style="font-weight:700;color:#a71d5d">_</span><span>&gt;,
</span></td></tr><tr><td>9</td><td><span>    tx: mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>Sender&lt;R&gt;,
</span></td></tr><tr><td>10</td><td><span>    func: F,
</span></td></tr><tr><td>11</td><td><span>) </span><span style="font-weight:700;color:#a71d5d">where
</span></td></tr><tr><td>12</td><td><span>    F: FnOnce() -&gt; R + Send + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></td></tr><tr><td>13</td><td><span>    R: Send + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></td></tr><tr><td>14</td><td><span>{
</span></td></tr><tr><td><mark style="background-color:#efefb8">15</mark></td><td><mark style="background-color:#efefb8"><span>    </span><span style="font-style:italic;color:#969896">// Spawn the new thread in the scope.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">16</mark></td><td><mark style="background-color:#efefb8"><span>    scope</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">spawn</span><span>(</span><span style="font-weight:700;color:#a71d5d">move || </span><span>{
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">17</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> result </span><span style="font-weight:700;color:#a71d5d">= </span><span style="color:#62a35c">func</span><span>();
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">18</mark></td><td><mark style="background-color:#efefb8"><span>        tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(result)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">19</mark></td><td><mark style="background-color:#efefb8"><span>    });
</span></mark></td></tr><tr><td>20</td><td><span>}
</span></td></tr><tr><td>21</td><td><span>
</span></td></tr><tr><td>22</td><td><span style="font-style:italic;color:#969896">// I'll call this function from my threads.
</span></td></tr><tr><td>23</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">target_fn</span><span>(sleep_duration: </span><span style="font-weight:700;color:#a71d5d">u64</span><span>) -&gt; </span><span style="font-weight:700;color:#a71d5d">u64 </span><span>{
</span></td></tr><tr><td>24</td><td><span>    println!(</span><span style="color:#183691">"Sleeping for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>25</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>sleep(Duration</span><span style="font-weight:700;color:#a71d5d">::</span><span>from_secs(sleep_duration));
</span></td></tr><tr><td>26</td><td><span>    sleep_duration
</span></td></tr><tr><td>27</td><td><span>}
</span></td></tr><tr><td>28</td><td><span>
</span></td></tr><tr><td>29</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">main</span><span>() {
</span></td></tr><tr><td>30</td><td><span>    </span><span style="font-style:italic;color:#969896">// Create the thread scope.
</span></td></tr><tr><td>31</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>scope(</span><span style="font-weight:700;color:#a71d5d">move |</span><span>scope</span><span style="font-weight:700;color:#a71d5d">| </span><span>{
</span></td></tr><tr><td>32</td><td><span>        </span><span style="font-style:italic;color:#969896">// Create the channel that the new threads will use to send their results to the main
</span></td></tr><tr><td>33</td><td><span>        </span><span style="font-style:italic;color:#969896">// thread.
</span></td></tr><tr><td>34</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let </span><span>(tx, rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></td></tr><tr><td>35</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">36</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="color:#62a35c">spawn_thread_in_scope</span><span>(scope, tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), </span><span style="font-weight:700;color:#a71d5d">move || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">1</span><span>));
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">37</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="color:#62a35c">spawn_thread_in_scope</span><span>(scope, tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), </span><span style="font-weight:700;color:#a71d5d">move || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">3</span><span>));
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">38</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="color:#62a35c">spawn_thread_in_scope</span><span>(scope, tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), </span><span style="font-weight:700;color:#a71d5d">move || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">5</span><span>));
</span></mark></td></tr><tr><td>39</td><td><span>
</span></td></tr><tr><td>40</td><td><span>        </span><span style="font-style:italic;color:#969896">// Drop `tx` so that when all the threads are finished and all the `tx` clones are dropped,
</span></td></tr><tr><td>41</td><td><span>        </span><span style="font-style:italic;color:#969896">// `rx` will return `Err`.
</span></td></tr><tr><td>42</td><td><span>        </span><span style="color:#62a35c">drop</span><span>(tx);
</span></td></tr><tr><td>43</td><td><span>
</span></td></tr><tr><td>44</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> start_time </span><span style="font-weight:700;color:#a71d5d">= </span><span>Instant</span><span style="font-weight:700;color:#a71d5d">::</span><span>now();
</span></td></tr><tr><td>45</td><td><span>        </span><span style="font-style:italic;color:#969896">// Receive the result from the next thread that sends one.
</span></td></tr><tr><td><mark style="background-color:#efefb8">46</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-weight:700;color:#a71d5d">while let </span><span style="color:#0086b3">Ok</span><span>(result) </span><span style="font-weight:700;color:#a71d5d">=</span><span> rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>() {
</span></mark></td></tr><tr><td>47</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">let</span><span> time_elapsed </span><span style="font-weight:700;color:#a71d5d">=</span><span> start_time</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">elapsed</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">as_secs_f64</span><span>();
</span></td></tr><tr><td>48</td><td><span>            println!(</span><span style="color:#183691">"</span><span style="color:#0086b3">{time_elapsed:.2}</span><span style="color:#183691">: Thread finished: slept for </span><span style="color:#0086b3">{result}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>49</td><td><span>        }
</span></td></tr><tr><td>50</td><td><span>    });
</span></td></tr><tr><td>51</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_threads_sending_results.rs">Source: rust_threads_sending_results.rs</a></p></pre><p>No surprise, here’s the outcome:</p><pre style="background-color:#f1f1f1;color:#323232"><code><span>Sleeping for 1 seconds.
</span><span>Sleeping for 5 seconds.
</span><span>Sleeping for 3 seconds.
</span><span>1.01: Thread finished: slept for 1 seconds.
</span><span>3.01: Thread finished: slept for 3 seconds.
</span><span>5.01: Thread finished: slept for 5 seconds.
</span></code></pre><p>But what if the thread panics? You may still want to handle panics in your code. This is where the additional complexity appears.</p><p>In that case, you’ll need to make sure that <code>func</code> is <a href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html">“unwind-safe”</a>, meaning that when a panic happens inside, the program is still left in a state that it can continue to run without the risk of memory safety issues. Then, call <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>panic::catch_unwind</code></a> when running the function and process the result, which could be an <code>Ok</code> variant carrying the return value from the function, or <code>Err</code> with the string that was passed into <code>panic!</code>. You may optionally choose to resume the unwinding with <a href="https://doc.rust-lang.org/std/panic/fn.resume_unwind.html"><code>panic::resume_unwind</code></a>.</p><p>Here’s how that can be done:</p><pre data-linenos="" data-lang="rust" data-name="rust_threads_sending_results_panic.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_threads_sending_results_panic.rs">Source: rust_threads_sending_results_panic.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_threads_sending_results_panic.rs"><table><tbody><tr><td>1</td><td><span style="font-weight:700;color:#a71d5d">use </span><span>std</span><span style="font-weight:700;color:#a71d5d">::</span><span>{
</span></td></tr><tr><td>2</td><td><span>    panic,
</span></td></tr><tr><td>3</td><td><span>    sync</span><span style="font-weight:700;color:#a71d5d">::</span><span>mpsc,
</span></td></tr><tr><td>4</td><td><span>    thread,
</span></td></tr><tr><td>5</td><td><span>    time</span><span style="font-weight:700;color:#a71d5d">::</span><span>{Duration, Instant},
</span></td></tr><tr><td>6</td><td><span>};
</span></td></tr><tr><td>7</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">8</mark></td><td><mark style="background-color:#efefb8"><span style="font-style:italic;color:#969896">// We'll use this enum to represent either a successful result or a panic.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">9</mark></td><td><mark style="background-color:#efefb8"><span style="font-weight:700;color:#a71d5d">enum </span><span>ThreadResult&lt;T&gt; {
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">10</mark></td><td><mark style="background-color:#efefb8"><span>    Success(T),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">11</mark></td><td><mark style="background-color:#efefb8"><span>    Panic(</span><span style="color:#0086b3">String</span><span>),
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">12</mark></td><td><mark style="background-color:#efefb8"><span>}
</span></mark></td></tr><tr><td>13</td><td><span>
</span></td></tr><tr><td>14</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">spawn_thread_in_scope</span><span>&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, F, R&gt;(
</span></td></tr><tr><td>15</td><td><span>    scope: </span><span style="font-weight:700;color:#a71d5d">&amp;'scope </span><span>thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>Scope&lt;</span><span style="font-weight:700;color:#a71d5d">'scope</span><span>, '</span><span style="font-weight:700;color:#a71d5d">_</span><span>&gt;,
</span></td></tr><tr><td>16</td><td><span>    tx: mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>Sender&lt;ThreadResult&lt;R&gt;&gt;,
</span></td></tr><tr><td>17</td><td><span>    func: F,
</span></td></tr><tr><td>18</td><td><span>) </span><span style="font-weight:700;color:#a71d5d">where
</span></td></tr><tr><td><mark style="background-color:#efefb8">19</mark></td><td><mark style="background-color:#efefb8"><span>    F: FnOnce() -&gt; R + Send + panic</span><span style="font-weight:700;color:#a71d5d">::</span><span>UnwindSafe + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></mark></td></tr><tr><td>20</td><td><span>    R: Send + </span><span style="font-weight:700;color:#a71d5d">'scope</span><span>,
</span></td></tr><tr><td>21</td><td><span>{
</span></td></tr><tr><td>22</td><td><span>    </span><span style="font-style:italic;color:#969896">// Spawn the new thread in the scope.
</span></td></tr><tr><td>23</td><td><span>    scope</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">spawn</span><span>(</span><span style="font-weight:700;color:#a71d5d">move || </span><span>{
</span></td></tr><tr><td><mark style="background-color:#efefb8">24</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-style:italic;color:#969896">// Catch any panic that might occur during the execution of the function.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">25</mark></td><td><mark style="background-color:#efefb8"><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> result </span><span style="font-weight:700;color:#a71d5d">= </span><span>panic</span><span style="font-weight:700;color:#a71d5d">::</span><span>catch_unwind(func);
</span></mark></td></tr><tr><td>26</td><td><span>
</span></td></tr><tr><td>27</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">match</span><span> result {
</span></td></tr><tr><td>28</td><td><span>            </span><span style="color:#0086b3">Ok</span><span>(success) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>{
</span></td></tr><tr><td><mark style="background-color:#efefb8">29</mark></td><td><mark style="background-color:#efefb8"><span>                </span><span style="font-style:italic;color:#969896">// The function executed successfully.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">30</mark></td><td><mark style="background-color:#efefb8"><span>                tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(ThreadResult</span><span style="font-weight:700;color:#a71d5d">::</span><span>Success(success))</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td>31</td><td><span>            }
</span></td></tr><tr><td>32</td><td><span>            </span><span style="color:#0086b3">Err</span><span>(panic_info) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>{
</span></td></tr><tr><td>33</td><td><span>                </span><span style="font-style:italic;color:#969896">// Function panicked, extract panic message.
</span></td></tr><tr><td>34</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> panic_msg </span><span style="font-weight:700;color:#a71d5d">= if let </span><span style="color:#0086b3">Some</span><span>(msg) </span><span style="font-weight:700;color:#a71d5d">=</span><span> panic_info</span><span style="font-weight:700;color:#a71d5d">.</span><span>downcast_ref</span><span style="font-weight:700;color:#a71d5d">::</span><span>&lt;</span><span style="font-weight:700;color:#a71d5d">&amp;str</span><span>&gt;() {
</span></td></tr><tr><td>35</td><td><span>                    (</span><span style="font-weight:700;color:#a71d5d">*</span><span>msg)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">to_string</span><span>()
</span></td></tr><tr><td>36</td><td><span>                } </span><span style="font-weight:700;color:#a71d5d">else if let </span><span style="color:#0086b3">Some</span><span>(msg) </span><span style="font-weight:700;color:#a71d5d">=</span><span> panic_info</span><span style="font-weight:700;color:#a71d5d">.</span><span>downcast_ref</span><span style="font-weight:700;color:#a71d5d">::</span><span>&lt;</span><span style="color:#0086b3">String</span><span>&gt;() {
</span></td></tr><tr><td>37</td><td><span>                    msg</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>()
</span></td></tr><tr><td>38</td><td><span>                } </span><span style="font-weight:700;color:#a71d5d">else </span><span>{
</span></td></tr><tr><td>39</td><td><span>                    </span><span style="color:#183691">"Unknown panic"</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">to_string</span><span>()
</span></td></tr><tr><td>40</td><td><span>                };
</span></td></tr><tr><td>41</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">42</mark></td><td><mark style="background-color:#efefb8"><span>                </span><span style="font-style:italic;color:#969896">// Send the panic message.
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">43</mark></td><td><mark style="background-color:#efefb8"><span>                tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(ThreadResult</span><span style="font-weight:700;color:#a71d5d">::</span><span>Panic(panic_msg))</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></mark></td></tr><tr><td>44</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">45</mark></td><td><mark style="background-color:#efefb8"><span>                panic</span><span style="font-weight:700;color:#a71d5d">::</span><span>resume_unwind(panic_info);
</span></mark></td></tr><tr><td>46</td><td><span>            }
</span></td></tr><tr><td>47</td><td><span>        }
</span></td></tr><tr><td>48</td><td><span>    });
</span></td></tr><tr><td>49</td><td><span>}
</span></td></tr><tr><td>50</td><td><span>
</span></td></tr><tr><td>51</td><td><span style="font-style:italic;color:#969896">// I'll call this function from my threads.
</span></td></tr><tr><td>52</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">target_fn</span><span>(sleep_duration: </span><span style="font-weight:700;color:#a71d5d">u64</span><span>) -&gt; </span><span style="font-weight:700;color:#a71d5d">u64 </span><span>{
</span></td></tr><tr><td>53</td><td><span>    println!(</span><span style="color:#183691">"Sleeping for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>54</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>sleep(Duration</span><span style="font-weight:700;color:#a71d5d">::</span><span>from_secs(sleep_duration));
</span></td></tr><tr><td>55</td><td><span>
</span></td></tr><tr><td>56</td><td><span>    </span><span style="font-style:italic;color:#969896">// To demonstrate panic handling, let's make it panic for a specific duration.
</span></td></tr><tr><td>57</td><td><span>    #[allow(clippy::manual_assert)]
</span></td></tr><tr><td>58</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">if</span><span> sleep_duration </span><span style="font-weight:700;color:#a71d5d">== </span><span style="color:#0086b3">3 </span><span>{
</span></td></tr><tr><td>59</td><td><span>        panic!(</span><span style="color:#183691">"Intentional panic in thread with sleep_duration = 3"</span><span>);
</span></td></tr><tr><td>60</td><td><span>    }
</span></td></tr><tr><td>61</td><td><span>
</span></td></tr><tr><td>62</td><td><span>    sleep_duration
</span></td></tr><tr><td>63</td><td><span>}
</span></td></tr><tr><td>64</td><td><span>
</span></td></tr><tr><td>65</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">main</span><span>() {
</span></td></tr><tr><td>66</td><td><span>    </span><span style="font-style:italic;color:#969896">// Create the thread scope.
</span></td></tr><tr><td>67</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>scope(</span><span style="font-weight:700;color:#a71d5d">move |</span><span>scope</span><span style="font-weight:700;color:#a71d5d">| </span><span>{
</span></td></tr><tr><td>68</td><td><span>        </span><span style="font-style:italic;color:#969896">// Create the channel that the new threads will use to send their results to the main
</span></td></tr><tr><td>69</td><td><span>        </span><span style="font-style:italic;color:#969896">// thread.
</span></td></tr><tr><td>70</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let </span><span>(tx, rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></td></tr><tr><td>71</td><td><span>
</span></td></tr><tr><td>72</td><td><span>        </span><span style="color:#62a35c">spawn_thread_in_scope</span><span>(scope, tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), </span><span style="font-weight:700;color:#a71d5d">move || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">1</span><span>));
</span></td></tr><tr><td>73</td><td><span>        </span><span style="color:#62a35c">spawn_thread_in_scope</span><span>(scope, tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), </span><span style="font-weight:700;color:#a71d5d">move || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">3</span><span>));
</span></td></tr><tr><td>74</td><td><span>        </span><span style="color:#62a35c">spawn_thread_in_scope</span><span>(scope, tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), </span><span style="font-weight:700;color:#a71d5d">move || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">5</span><span>));
</span></td></tr><tr><td>75</td><td><span>
</span></td></tr><tr><td>76</td><td><span>        </span><span style="font-style:italic;color:#969896">// Drop `tx` so that when all the threads are finished and all the `tx` clones are dropped,
</span></td></tr><tr><td>77</td><td><span>        </span><span style="font-style:italic;color:#969896">// `rx` will return `Err`.
</span></td></tr><tr><td>78</td><td><span>        </span><span style="color:#62a35c">drop</span><span>(tx);
</span></td></tr><tr><td>79</td><td><span>
</span></td></tr><tr><td>80</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> start_time </span><span style="font-weight:700;color:#a71d5d">= </span><span>Instant</span><span style="font-weight:700;color:#a71d5d">::</span><span>now();
</span></td></tr><tr><td>81</td><td><span>        </span><span style="font-style:italic;color:#969896">// Receive the result from the next thread that sends one.
</span></td></tr><tr><td>82</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">while let </span><span style="color:#0086b3">Ok</span><span>(thread_result) </span><span style="font-weight:700;color:#a71d5d">=</span><span> rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>() {
</span></td></tr><tr><td>83</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">let</span><span> time_elapsed </span><span style="font-weight:700;color:#a71d5d">=</span><span> start_time</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">elapsed</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">as_secs_f64</span><span>();
</span></td></tr><tr><td>84</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#efefb8">85</mark></td><td><mark style="background-color:#efefb8"><span>            </span><span style="font-weight:700;color:#a71d5d">match</span><span> thread_result {
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">86</mark></td><td><mark style="background-color:#efefb8"><span>                ThreadResult</span><span style="font-weight:700;color:#a71d5d">::</span><span>Success(result) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>{
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">87</mark></td><td><mark style="background-color:#efefb8"><span>                    println!(
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">88</mark></td><td><mark style="background-color:#efefb8"><span>                        </span><span style="color:#183691">"</span><span style="color:#0086b3">{time_elapsed:.2}</span><span style="color:#183691">: Thread finished successfully: slept for </span><span style="color:#0086b3">{result}</span><span style="color:#183691"> seconds."
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">89</mark></td><td><mark style="background-color:#efefb8"><span>                    );
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">90</mark></td><td><mark style="background-color:#efefb8"><span>                }
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">91</mark></td><td><mark style="background-color:#efefb8"><span>                ThreadResult</span><span style="font-weight:700;color:#a71d5d">::</span><span>Panic(panic_msg) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>{
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">92</mark></td><td><mark style="background-color:#efefb8"><span>                    println!(</span><span style="color:#183691">"</span><span style="color:#0086b3">{time_elapsed:.2}</span><span style="color:#183691">: Thread panicked with message: </span><span style="color:#0086b3">{panic_msg}</span><span style="color:#183691">"</span><span>);
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">93</mark></td><td><mark style="background-color:#efefb8"><span>                }
</span></mark></td></tr><tr><td><mark style="background-color:#efefb8">94</mark></td><td><mark style="background-color:#efefb8"><span>            }
</span></mark></td></tr><tr><td>95</td><td><span>        }
</span></td></tr><tr><td>96</td><td><span>    });
</span></td></tr><tr><td>97</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_threads_sending_results_panic.rs">Source: rust_threads_sending_results_panic.rs</a></p></pre><p>First, we’ll need an enum to signal whether the thread finished successfully or not, that’s <code>ThreadResult</code> in the code above. Then, in the thread, call the target function wrapped in <code>panic::catch_unwind</code> (the function must be unwind-safe, otherwise that will give us a compiler error).</p><p>Then, process the result: if it is an <code>Ok</code> variant, then the target function completed successfully and the return value is wrapped in the <code>Ok</code>. Get the return value, wrap it inside <code>ThreadResult</code>, and send it into the channel. If it is <code>Err</code>, then you need to wrap the panic message in <code>ThreadResult::Panic</code>, send it into the channel, and resume the unwinding with <a href="https://doc.rust-lang.org/std/panic/fn.resume_unwind.html"><code>panic::resume_unwind</code></a>.</p><p>Finally, process the <code>ThreadResult</code> in the parent thread as needed.</p><p>Since the threads are not being joined, you’ll still get messages in <code>stderr</code> warning that some threads have panicked. Depending on your specific situation, this may be a minor inconvenience.</p><h2 id="conclusion">Conclusion</h2><p>This post presents two ways to handle joining multiple threads immediately as they finish in Rust, in ways in which it is also possible to process the threads’ results or panics.</p><p>The first involves passing spawned thread handles from the parent thread to the spawned thread, and back when it is ready. The other involves passing values from the spawned threads to the parent thread directly. Each approach allows handling panics, but in different ways. The first approach leaves panic-handling to the Rust runtime, and trust the unwinding mechanism to pass the thread handles to the calling thread. The second approach handles panics explicitly in first-party code.</p><p>Whether to use the first or the second approach, it’s always a matter of judgement based on the specific situation in which we currently find ourselves, and a matter of personal preference if no approach offers an objective advantage.</p><p>When it’s just a matter of personal preference, I will probably prefer the first approach more often than the second, since leveraging the Rust runtime unwinding mechanism seems like a considerable advantage and an opportunity to reduce the complexity of my code by adhering better to Rust’s threading model: not having to handle panics explicitly, not having to worry about unwinding-safety, not having to worry about messages to <code>stderr</code>, etc.</p><h2 id="appendix-a">Appendix A: Does it work with regular threads too?</h2><p>This works with regular threads too, not only scoped threads. See the code below.</p><pre data-linenos="" data-lang="rust" data-name="rust_self_shipping_regular_threads.rs" style="background-color:#f1f1f1;color:#323232" class="language-rust"><p class="filename"><a href="rust_self_shipping_regular_threads.rs">Source: rust_self_shipping_regular_threads.rs</a></p><code class="language-rust" data-lang="rust" data-name="rust_self_shipping_regular_threads.rs"><table><tbody><tr><td>1</td><td><span style="font-weight:700;color:#a71d5d">use </span><span>std</span><span style="font-weight:700;color:#a71d5d">::</span><span>{
</span></td></tr><tr><td>2</td><td><span>    sync</span><span style="font-weight:700;color:#a71d5d">::</span><span>mpsc,
</span></td></tr><tr><td>3</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>{self, JoinHandle},
</span></td></tr><tr><td>4</td><td><span>    time</span><span style="font-weight:700;color:#a71d5d">::</span><span>{Duration, Instant},
</span></td></tr><tr><td>5</td><td><span>};
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span style="font-style:italic;color:#969896">// A struct with a `Drop` implementation to ensure the thread handle is sent to the caller of
</span></td></tr><tr><td>8</td><td><span style="font-style:italic;color:#969896">// `spawn_self_shipping_thread` even if the self-shipping thread panics.
</span></td></tr><tr><td>9</td><td><span style="font-weight:700;color:#a71d5d">struct </span><span>SendOnDrop&lt;R&gt; {
</span></td></tr><tr><td>10</td><td><span>    handle: </span><span style="color:#0086b3">Option</span><span>&lt;JoinHandle&lt;R&gt;&gt;,
</span></td></tr><tr><td>11</td><td><span>    tx: mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>Sender&lt;JoinHandle&lt;R&gt;&gt;,
</span></td></tr><tr><td>12</td><td><span>}
</span></td></tr><tr><td>13</td><td><span>
</span></td></tr><tr><td>14</td><td><span style="font-weight:700;color:#a71d5d">impl</span><span>&lt;R&gt; Drop </span><span style="font-weight:700;color:#a71d5d">for </span><span>SendOnDrop&lt;R&gt; {
</span></td></tr><tr><td>15</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">drop</span><span>(</span><span style="font-weight:700;color:#a71d5d">&amp;mut </span><span>self) {
</span></td></tr><tr><td>16</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">if let </span><span style="color:#0086b3">Some</span><span>(handle) </span><span style="font-weight:700;color:#a71d5d">= </span><span>self</span><span style="font-weight:700;color:#a71d5d">.</span><span>handle</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">take</span><span>() {
</span></td></tr><tr><td>17</td><td><span>            self</span><span style="font-weight:700;color:#a71d5d">.</span><span>tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(handle)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>18</td><td><span>        }
</span></td></tr><tr><td>19</td><td><span>    }
</span></td></tr><tr><td>20</td><td><span>}
</span></td></tr><tr><td>21</td><td><span>
</span></td></tr><tr><td>22</td><td><span style="font-weight:700;color:#a71d5d">pub fn </span><span style="font-weight:700;color:#795da3">spawn_self_shipping_thread</span><span>&lt;F, R&gt;(tx: mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>Sender&lt;JoinHandle&lt;R&gt;&gt;, func: F)
</span></td></tr><tr><td>23</td><td><span style="font-weight:700;color:#a71d5d">where
</span></td></tr><tr><td>24</td><td><span>    F: FnOnce() -&gt; R + Send + </span><span style="font-weight:700;color:#a71d5d">'static</span><span>,
</span></td></tr><tr><td>25</td><td><span>    R: Send + </span><span style="font-weight:700;color:#a71d5d">'static</span><span>,
</span></td></tr><tr><td>26</td><td><span>{
</span></td></tr><tr><td>27</td><td><span>    </span><span style="font-style:italic;color:#969896">// Create the channel that will be used to transfer the new thread's handle from the parent
</span></td></tr><tr><td>28</td><td><span>    </span><span style="font-style:italic;color:#969896">// thread to the new thread.
</span></td></tr><tr><td>29</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">let </span><span>(handle_tx, handle_rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></td></tr><tr><td>30</td><td><span>
</span></td></tr><tr><td>31</td><td><span>    </span><span style="font-style:italic;color:#969896">// Spawn the new thread in the scope.
</span></td></tr><tr><td>32</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">= </span><span>std</span><span style="font-weight:700;color:#a71d5d">::</span><span>thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>spawn(</span><span style="font-weight:700;color:#a71d5d">move || </span><span>{
</span></td></tr><tr><td>33</td><td><span>        </span><span style="font-style:italic;color:#969896">// Receive the handler that was sent by the parent thread to the new thread via the
</span></td></tr><tr><td>34</td><td><span>        </span><span style="font-style:italic;color:#969896">// channel.
</span></td></tr><tr><td>35</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle_rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>36</td><td><span>
</span></td></tr><tr><td>37</td><td><span>        </span><span style="font-style:italic;color:#969896">// This will send the new thread's handle to the caller of
</span></td></tr><tr><td>38</td><td><span>        </span><span style="font-style:italic;color:#969896">// `spawn_self_shipping_thread_in_scope` when the thread stack is destroyed, even if that
</span></td></tr><tr><td>39</td><td><span>        </span><span style="font-style:italic;color:#969896">// happens due to a panic.
</span></td></tr><tr><td>40</td><td><span>        SendOnDrop {
</span></td></tr><tr><td>41</td><td><span>            handle: </span><span style="color:#0086b3">Some</span><span>(handle),
</span></td></tr><tr><td>42</td><td><span>            </span><span style="font-style:italic;color:#969896">// It is responsibility of the caller to make sure that the `rx` side of this channel
</span></td></tr><tr><td>43</td><td><span>            </span><span style="font-style:italic;color:#969896">// is alive until after this thread is finished.
</span></td></tr><tr><td>44</td><td><span>            tx,
</span></td></tr><tr><td>45</td><td><span>        };
</span></td></tr><tr><td>46</td><td><span>
</span></td></tr><tr><td>47</td><td><span>        </span><span style="font-style:italic;color:#969896">// Execute the target function and return its result.
</span></td></tr><tr><td>48</td><td><span>        </span><span style="color:#62a35c">func</span><span>()
</span></td></tr><tr><td>49</td><td><span>    });
</span></td></tr><tr><td>50</td><td><span>
</span></td></tr><tr><td>51</td><td><span>    </span><span style="font-style:italic;color:#969896">// Send the new thread's handle into the new thread itself.
</span></td></tr><tr><td>52</td><td><span>    handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">send</span><span>(handle)</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>53</td><td><span>}
</span></td></tr><tr><td>54</td><td><span>
</span></td></tr><tr><td>55</td><td><span style="font-style:italic;color:#969896">// I'll call this function from my threads.
</span></td></tr><tr><td>56</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">target_fn</span><span>(sleep_duration: </span><span style="font-weight:700;color:#a71d5d">u64</span><span>) -&gt; </span><span style="font-weight:700;color:#a71d5d">u64 </span><span>{
</span></td></tr><tr><td>57</td><td><span>    println!(</span><span style="color:#183691">"Sleeping for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>58</td><td><span>    thread</span><span style="font-weight:700;color:#a71d5d">::</span><span>sleep(Duration</span><span style="font-weight:700;color:#a71d5d">::</span><span>from_secs(sleep_duration));
</span></td></tr><tr><td>59</td><td><span>    sleep_duration
</span></td></tr><tr><td>60</td><td><span>}
</span></td></tr><tr><td>61</td><td><span>
</span></td></tr><tr><td>62</td><td><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">main</span><span>() {
</span></td></tr><tr><td>63</td><td><span>    </span><span style="font-style:italic;color:#969896">// Create the channel that the new threads will use to send their handles to the main thread.
</span></td></tr><tr><td>64</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">let </span><span>(handle_tx, handle_rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></td></tr><tr><td>65</td><td><span>
</span></td></tr><tr><td>66</td><td><span>    </span><span style="font-style:italic;color:#969896">// Spawn the new threads.
</span></td></tr><tr><td>67</td><td><span>    </span><span style="color:#62a35c">spawn_self_shipping_thread</span><span>(handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">1</span><span>));
</span></td></tr><tr><td>68</td><td><span>    </span><span style="color:#62a35c">spawn_self_shipping_thread</span><span>(handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">3</span><span>));
</span></td></tr><tr><td>69</td><td><span>    </span><span style="color:#62a35c">spawn_self_shipping_thread</span><span>(handle_tx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">clone</span><span>(), || </span><span style="color:#62a35c">target_fn</span><span>(</span><span style="color:#0086b3">5</span><span>));
</span></td></tr><tr><td>70</td><td><span>
</span></td></tr><tr><td>71</td><td><span>    </span><span style="font-style:italic;color:#969896">// Drop this `handle_tx` so that when all the threads are finished and all the `handle_tx`
</span></td></tr><tr><td>72</td><td><span>    </span><span style="font-style:italic;color:#969896">// clones are dropped, `handle_rx` will return `Err`.
</span></td></tr><tr><td>73</td><td><span>    </span><span style="color:#62a35c">drop</span><span>(handle_tx);
</span></td></tr><tr><td>74</td><td><span>
</span></td></tr><tr><td>75</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">let</span><span> start_time </span><span style="font-weight:700;color:#a71d5d">= </span><span>Instant</span><span style="font-weight:700;color:#a71d5d">::</span><span>now();
</span></td></tr><tr><td>76</td><td><span>    </span><span style="font-style:italic;color:#969896">// Receive the handle from the next thread that finishes.
</span></td></tr><tr><td>77</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">while let </span><span style="color:#0086b3">Ok</span><span>(handle) </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle_rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>() {
</span></td></tr><tr><td>78</td><td><span>        </span><span style="font-style:italic;color:#969896">// Join the thread and get the result.
</span></td></tr><tr><td>79</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">match</span><span> handle</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">join</span><span>() {
</span></td></tr><tr><td>80</td><td><span>            </span><span style="color:#0086b3">Ok</span><span>(sleep_duration) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>{
</span></td></tr><tr><td>81</td><td><span>                </span><span style="font-weight:700;color:#a71d5d">let</span><span> time_elapsed </span><span style="font-weight:700;color:#a71d5d">=</span><span> start_time</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">elapsed</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">as_secs_f64</span><span>();
</span></td></tr><tr><td>82</td><td><span>                println!(</span><span style="color:#183691">"</span><span style="color:#0086b3">{time_elapsed:.2}</span><span style="color:#183691">: Thread finished: slept for </span><span style="color:#0086b3">{sleep_duration}</span><span style="color:#183691"> seconds."</span><span>);
</span></td></tr><tr><td>83</td><td><span>            }
</span></td></tr><tr><td>84</td><td><span>            </span><span style="color:#0086b3">Err</span><span>(e) </span><span style="font-weight:700;color:#a71d5d">=&gt; </span><span>eprintln!(</span><span style="color:#183691">"Error joining thread: </span><span style="color:#0086b3">{e:?}</span><span style="color:#183691">"</span><span>),
</span></td></tr><tr><td>85</td><td><span>        }
</span></td></tr><tr><td>86</td><td><span>    }
</span></td></tr><tr><td>87</td><td><span>}
</span></td></tr><tr><td>88</td><td><span>
</span></td></tr><tr><td>89</td><td><span>#[cfg(test)]
</span></td></tr><tr><td>90</td><td><span style="font-weight:700;color:#a71d5d">mod </span><span>tests {
</span></td></tr><tr><td>91</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">use super::*</span><span>;
</span></td></tr><tr><td>92</td><td><span>
</span></td></tr><tr><td>93</td><td><span>    </span><span style="font-weight:700;color:#a71d5d">mod </span><span>spawn_self_shipping_thread {
</span></td></tr><tr><td>94</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">use super::*</span><span>;
</span></td></tr><tr><td>95</td><td><span>
</span></td></tr><tr><td>96</td><td><span>        #[test]
</span></td></tr><tr><td>97</td><td><span>        </span><span style="font-weight:700;color:#a71d5d">fn </span><span style="font-weight:700;color:#795da3">handles_panic</span><span>() {
</span></td></tr><tr><td>98</td><td><span>            </span><span style="font-style:italic;color:#969896">// Create the channel.
</span></td></tr><tr><td>99</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">let </span><span>(tx, rx) </span><span style="font-weight:700;color:#a71d5d">= </span><span>mpsc</span><span style="font-weight:700;color:#a71d5d">::</span><span>channel();
</span></td></tr><tr><td>100</td><td><span>
</span></td></tr><tr><td>101</td><td><span>            </span><span style="font-style:italic;color:#969896">// Spawn the self-shipping thread. Make it panic.
</span></td></tr><tr><td>102</td><td><span>            </span><span style="color:#62a35c">spawn_self_shipping_thread</span><span>(tx, || {
</span></td></tr><tr><td>103</td><td><span>                panic!(</span><span style="color:#183691">"Thread is panicking on purpose for testing"</span><span>);
</span></td></tr><tr><td>104</td><td><span>            });
</span></td></tr><tr><td>105</td><td><span>
</span></td></tr><tr><td>106</td><td><span>            </span><span style="font-style:italic;color:#969896">// Ensure something was sent over the channel.
</span></td></tr><tr><td>107</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">let</span><span> handle </span><span style="font-weight:700;color:#a71d5d">=</span><span> rx</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">recv</span><span>()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>108</td><td><span>            </span><span style="font-style:italic;color:#969896">// Join the self-shipping thread.
</span></td></tr><tr><td>109</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">let</span><span> join_result </span><span style="font-weight:700;color:#a71d5d">=</span><span> handle</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">join</span><span>();
</span></td></tr><tr><td>110</td><td><span>            </span><span style="font-style:italic;color:#969896">// And see that it errored with our custom panic message.
</span></td></tr><tr><td>111</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">let</span><span> err </span><span style="font-weight:700;color:#a71d5d">=</span><span> join_result</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap_err</span><span>();
</span></td></tr><tr><td>112</td><td><span>            </span><span style="font-weight:700;color:#a71d5d">let</span><span> panic_msg </span><span style="font-weight:700;color:#a71d5d">=</span><span> err</span><span style="font-weight:700;color:#a71d5d">.</span><span>downcast_ref</span><span style="font-weight:700;color:#a71d5d">::</span><span>&lt;</span><span style="font-weight:700;color:#a71d5d">&amp;str</span><span>&gt;()</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">unwrap</span><span>();
</span></td></tr><tr><td>113</td><td><span>            assert!(panic_msg</span><span style="font-weight:700;color:#a71d5d">.</span><span style="color:#62a35c">contains</span><span>(</span><span style="color:#183691">"Thread is panicking on purpose for testing"</span><span>));
</span></td></tr><tr><td>114</td><td><span>        }
</span></td></tr><tr><td>115</td><td><span>    }
</span></td></tr><tr><td>116</td><td><span>}
</span></td></tr></tbody></table></code><p class="filename"><a href="rust_self_shipping_regular_threads.rs">Source: rust_self_shipping_regular_threads.rs</a></p></pre><p><em>Edit 1 (2025-05-21): <a href="https://github.com/ericseppanen">Eric Seppanen</a> offered some suggestions on how this post could be improved:</em></p><ul><li><em>I edited the post to mention that it is possible to just not join the threads at all, and let them run in “detached” mode.</em></li><li><em>I added <a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#exploring-an-alternative-approach">the section about an alternative approach</a> and <a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#conclusion">the conclusion</a> comparing both approaches.</em></li></ul><div class="footnote-container"><div class="footnote-definition" id="footnote__simpler-threads-sending-results-implementation"><p>1. There’s a simpler way to achieve the same result: make the <code>target_fn</code> accept a <code>Sender</code>. However, I’m only interested in approaches that do not require changing the target function: it should work with any function, including from other crates. <a href="#footnote_ref__simpler-threads-sending-results-implementation">↩</a></p></div></div></div></div></div><div class="row posts-page-navigation posts-page-navigation-bottom"><div class="col-6"></div><div class="col-6"></div></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;ad1cb2b3b9ce401a8877b99ffd513a0d&quot;}"></script></body></html>