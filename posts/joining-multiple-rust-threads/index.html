<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/x-icon" href="/static/img/favicon.ico"><title>Joining threads immediately as they finish in Rust - João Sampaio - Software Engineer</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&amp;family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous"><link rel="stylesheet" href="https://jpmelos.com/static/css/base.css?h=890a7fe511b2c33774fe"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="https://jpmelos.com/atom.xml"></head><body><div class="container"><div class="row row-site-title"><div class="col-12"><div class="site-title-container"><a href="https://jpmelos.com" class="site-title">João Sampaio</a> <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode" title="Toggle dark mode"><svg class="theme-icon sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg> <svg class="theme-icon moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></div></div><div class="row row-top-links"><div class="col-6"><p><a href="https://jpmelos.com">Home</a> <a href="https://jpmelos.com/posts/">Posts</a></p></div><div class="col-6 row-top-links-right"><p><a href="https://jpmelos.com/atom.xml" target="_blank">Feed↗</a> <a href="https://jpmelos.com/resume/" target="_blank">Resume↗</a></p></div></div><div class="row"><div class="col-12 content"><div class="row posts-page-navigation posts-page-navigation-top"><div class="col-6"></div><div class="col-6"></div></div><div class="row"><div class="col-12"><div class="posts-page-content"><h1>Joining threads immediately as they finish in Rust</h1><p class="posts-page-metadata">2025-05-15</p><ol><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#what-is-the-problem">What is the problem?</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#how-does-it-work-in-python">How does it work in Python?</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#doing-the-same-thing-in-rust">Doing the same thing in Rust</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#self-shipping-threads-in-rust">“Self-shipping” threads in Rust</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#but-what-if-the-thread-panics">But what if the thread panics?</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#exploring-an-alternative-approach">Exploring an alternative approach</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#conclusion">Conclusion</a></li><li><a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#appendix-a">Appendix A: Does it work with regular threads too?</a></li></ol><h2 id="what-is-the-problem">What is the problem?</h2><p>As of Rust 1.87.0, if you want to join multiple threads using exclusively the standard library, joining them immediately as they finish (in case the order in which they finish is not deterministic) is not a straightforward task.</p><p>This post isn’t intended as criticism of Rust’s standard library. The absence of this feature may be an intentional design decision or simply a matter of priorities. Regardless, since joining threads is a common need, I’ll document my solution for future reference.</p><p>When you spawn threads, you get back a <a rel="external" href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"><code>JoinHandle</code></a> (this is true for <a rel="external" href="https://doc.rust-lang.org/std/thread/index.html">regular</a> and <a rel="external" href="https://doc.rust-lang.org/std/thread/fn.scope.html">scoped threads</a>, and they are equivalent for the purposes of this post, see <a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#appendix-a">Appendix A</a>). Then, you can decide to join on those threads, or not:</p><ol><li>If you decide not to join those threads and just let them run unattended, you can just let the <code>JoinHandle</code> drop and the threads will be automatically dealt with when they’re done running. The threads are called “detached”, and you won’t have a way to know when they have completed or otherwise terminated.</li><li>If you decide to join the threads, you’ll need to call <a rel="external" href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>JoinHandle::join</code></a> to join each of those threads individually. The problem is that <code>JoinHandle::join</code> blocks until the thread is finished. If you spawn multiple threads, which happens more often than not, there’s no way to wait on all of them simultaneously, and process each of them immediately as they finish.</li></ol><h2 id="how-does-it-work-in-python">How does it work in Python?</h2><p>Let’s see how it can be done in another language, and then try to achieve something similar in Rust.</p><p>In Python, there is the <a rel="external" href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor"><code>ThreadPoolExecutor</code></a>. As you spawn threads using <a rel="external" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit"><code>ThreadPoolExecutor.submit</code></a>, you get <a rel="external" href="https://docs.python.org/3/library/concurrent.futures.html#future-objects"><code>Future</code></a>s back, which you can store in an iterable. You can pass that iterable into the <a rel="external" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed"><code>concurrent.futures.as_completed</code></a> function, and it will yield those futures as they finish. You can process each future individually right then and there, and then immediately start waiting for the next one to finish.</p><pre class="giallo z-code"><p class="filename"><a href="python_threads_with_threadpool.py">Source: python_threads_with_threadpool.py</a></p><code data-lang="python" data-name="python_threads_with_threadpool.py"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 1</span><span class="z-keyword">import</span><span> concurrent</span><span>.</span><span>futures</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 2</span><span class="z-keyword">import</span><span> time</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 3</span><span class="z-keyword">from</span><span> concurrent</span><span>.</span><span>futures</span><span class="z-keyword"> import</span><span> ThreadPoolExecutor</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 4</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 5</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 6</span><span class="z-punctuation z-definition z-comment">#</span><span class="z-comment"> I'll call this function from my threads.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 7</span><span class="z-storage z-type">def</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-variable z-parameter z-function">sleep_duration</span><span>:</span><span class="z-support"> int</span><span>)</span><span> -&gt;</span><span class="z-support"> int</span><span>:</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 8</span><span class="z-support">    print</span><span>(</span><span class="z-storage z-type">f</span><span class="z-string">"</span><span class="z-string">Sleeping for </span><span class="z-constant z-character">{</span><span>sleep_duration</span><span class="z-constant z-character">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 9</span><span>    time</span><span>.</span><span>sleep</span><span>(</span><span>sleep_duration</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">10</span><span class="z-keyword">    return</span><span> sleep_duration</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">11</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">12</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">13</span><span>start_time</span><span class="z-keyword"> =</span><span> time</span><span>.</span><span>monotonic</span><span>(</span><span>)</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">14</span><span class="z-punctuation z-definition z-comment">#</span><span class="z-comment"> Using `ThreadPoolExecutor` as a context manager guarantees that all threads</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">15</span><span class="z-punctuation z-definition z-comment">#</span><span class="z-comment"> will be joined before the context manager's scope ends. This is very similar</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">16</span><span class="z-punctuation z-definition z-comment">#</span><span class="z-comment"> to Rust's scoped threads.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">17</span><span class="z-keyword">with</span><span> ThreadPoolExecutor</span><span>(</span><span>)</span><span class="z-keyword"> as</span><span> executor</span><span>:</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">18</span><span class="z-punctuation z-definition z-comment">    #</span><span class="z-comment"> Collect the futures into a set.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">19</span><span>    futures</span><span class="z-keyword"> =</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">20</span><span>        executor</span><span>.</span><span>submit</span><span>(</span><span>target_fn</span><span>,</span><span class="z-constant"> 5</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">21</span><span>        executor</span><span>.</span><span>submit</span><span>(</span><span>target_fn</span><span>,</span><span class="z-constant"> 3</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">22</span><span>        executor</span><span>.</span><span>submit</span><span>(</span><span>target_fn</span><span>,</span><span class="z-constant"> 1</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">23</span><span>    }</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">24</span><span class="z-punctuation z-definition z-comment">    #</span><span class="z-comment"> Get the futures as they finish using `as_completed`.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">25</span><span class="z-keyword">    for</span><span> future</span><span class="z-keyword"> in</span><span> concurrent</span><span>.</span><span>futures</span><span>.</span><span>as_completed</span><span>(</span><span>futures</span><span>)</span><span>:</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">26</span><span>        time_elapsed</span><span class="z-keyword"> =</span><span> time</span><span>.</span><span>monotonic</span><span>(</span><span>)</span><span class="z-keyword"> -</span><span> start_time</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">27</span><span>        return_value</span><span class="z-keyword"> =</span><span> future</span><span>.</span><span>result</span><span>(</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">28</span><span class="z-support">        print</span><span>(</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">29</span><span class="z-storage z-type">            f</span><span class="z-string">"</span><span class="z-constant z-character">{</span><span>time_elapsed</span><span class="z-storage z-type">:.2f</span><span class="z-constant z-character">}</span><span class="z-string">:</span><span class="z-string">"</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">30</span><span class="z-storage z-type">            f</span><span class="z-string">"</span><span class="z-string"> Thread finished:</span><span class="z-string">"</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">31</span><span class="z-storage z-type">            f</span><span class="z-string">"</span><span class="z-string"> slept for </span><span class="z-constant z-character">{</span><span>return_value</span><span class="z-constant z-character">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">32</span><span>        )</span></span></code><p class="filename"><a href="python_threads_with_threadpool.py">Source: python_threads_with_threadpool.py</a></p></pre><p>Running the code above with Python 3.13.2 yields this (with some variation regarding the timestamps):</p><pre class="giallo z-code"><code data-lang="plain"><span class="giallo-l"><span>Sleeping for 5 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 3 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 1 seconds.</span></span>
<span class="giallo-l"><span>1.00: Thread finished: slept for 1 seconds.</span></span>
<span class="giallo-l"><span>3.01: Thread finished: slept for 3 seconds.</span></span>
<span class="giallo-l"><span>5.01: Thread finished: slept for 5 seconds.</span></span></code></pre><p>You can tell from the timestamps in the last few lines that each thread was processed as soon as it finished.</p><h2 id="doing-the-same-thing-in-rust">Doing the same thing in Rust</h2><p>There’s nothing like <code>concurrent.futures.as_completed</code> in Rust’s standard library. <code>JoinHandle::join</code> will block until each thread finishes, you’ll need to call it once for each thread, and you don’t know when each thread will finish.</p><p>The method <a rel="external" href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.is_finished"><code>JoinHandle::is_finished</code></a> can be used to check whether a thread has already finished, and it will always return immediately with a boolean. Therefore, it is possible to use it with a looping sleep to keep watch for when threads finish. But you can’t make it happen without that loop.</p><p>Now, all that said, I’m sure this is a solved problem. There must be a crate somewhere that solves this exact problem in an elegant and performant way. But I decided to tackle this problem myself as an opportunity to deepen my understanding of Rust’s threading model.</p><p>First, I’ll implement a Rust program that manages several threads using the looping approach:</p><pre class="giallo z-code"><p class="filename"><a href="rust_threads_with_looping_sleep.rs">Source: rust_threads_with_looping_sleep.rs</a></p><code data-lang="rust" data-name="rust_threads_with_looping_sleep.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 1</span><span class="z-keyword">use</span><span class="z-entity z-name"> std</span><span class="z-keyword">::</span><span>thread</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 2</span><span class="z-keyword">use</span><span class="z-entity z-name"> std</span><span class="z-keyword">::</span><span class="z-entity z-name">time</span><span class="z-keyword">::</span><span>{</span><span class="z-entity z-name">Duration</span><span>,</span><span class="z-entity z-name"> Instant</span><span>}</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 3</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 4</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> I'll call this function from my threads.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 5</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span class="z-keyword">:</span><span class="z-entity z-name"> u64</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> u64</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 6</span><span class="z-entity z-name z-function">    println!</span><span>(</span><span class="z-string">"</span><span class="z-string">Sleeping for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 7</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">sleep</span><span>(</span><span class="z-entity z-name">Duration</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">from_secs</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 8</span><span class="z-variable z-other">    sleep_duration</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 9</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">10</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">11</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">12</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Spawn the threads and put all the handles in a vector.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">13</span><span class="z-storage z-type">    let</span><span class="z-storage"> mut</span><span class="z-variable z-other"> handles</span><span class="z-keyword"> =</span><span class="z-entity z-name z-function"> vec!</span><span>[</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">14</span><span class="z-entity z-name">        thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">|</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">5</span><span>)</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">15</span><span class="z-entity z-name">        thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">|</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">3</span><span>)</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">16</span><span class="z-entity z-name">        thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">|</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">1</span><span>)</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">17</span><span>    ]</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">18</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">19</span><span class="z-storage z-type">    let</span><span class="z-variable z-other"> start_time</span><span class="z-keyword"> =</span><span class="z-entity z-name"> Instant</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">now</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">20</span><span class="z-keyword">    while</span><span class="z-keyword"> !</span><span class="z-variable z-other">handles</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">is_empty</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">21</span><span class="z-storage z-type">        let</span><span class="z-storage"> mut</span><span class="z-variable z-other"> i</span><span class="z-keyword"> =</span><span class="z-constant"> 0</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">22</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">23</span><span class="z-keyword">        while</span><span class="z-variable z-other"> i</span><span class="z-keyword"> &lt;</span><span class="z-variable z-other"> handles</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">len</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">24</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> Call `JoinHandle.is_finished` for each thread, until one of them is.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">25</span><span class="z-keyword">            if</span><span class="z-variable z-other"> handles</span><span>[</span><span class="z-variable z-other">i</span><span>]</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">is_finished</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">26</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handles</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">remove</span><span>(</span><span class="z-variable z-other">i</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">27</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> Call `JoinHandle.join`, get the result, print it.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">28</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> sleep_duration</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">join</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">29</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> time_elapsed</span><span class="z-keyword"> =</span><span class="z-variable z-other"> start_time</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">elapsed</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">as_secs_f64</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">30</span><span class="z-entity z-name z-function">                println!</span><span>(</span><span class="z-string">"</span><span class="z-string">{</span><span class="z-string">time_elapsed:.2</span><span class="z-string">}</span><span class="z-string">: Thread finished: slept for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">31</span><span>            }</span><span class="z-keyword"> else</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">32</span><span class="z-variable z-other">                i</span><span class="z-keyword"> +=</span><span class="z-constant"> 1</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">33</span><span>            }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">34</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">35</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">36</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Sleep, the main thread yields control so the others can continue.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">37</span><span class="z-entity z-name">        thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">sleep</span><span>(</span><span class="z-entity z-name">Duration</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">from_millis</span><span>(</span><span class="z-constant">10</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">38</span><span>    }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">39</span><span>}</span></span></code><p class="filename"><a href="rust_threads_with_looping_sleep.rs">Source: rust_threads_with_looping_sleep.rs</a></p></pre><p>Here’s the output from that program:</p><pre class="giallo z-code"><code data-lang="plain"><span class="giallo-l"><span>Sleeping for 5 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 1 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 3 seconds.</span></span>
<span class="giallo-l"><span>1.00: Thread finished: slept for 1 seconds.</span></span>
<span class="giallo-l"><span>3.00: Thread finished: slept for 3 seconds.</span></span>
<span class="giallo-l"><span>5.01: Thread finished: slept for 5 seconds.</span></span></code></pre><p>That’s not terrible, but what if you don’t want to loop? I encountered this problem when writing <a rel="external" href="https://github.com/jpmelos/fdintercept"><code>fdintercept</code></a>.</p><h2 id="self-shipping-threads-in-rust">“Self-shipping” threads in Rust</h2><p>The solution that I found in Rust is this: let each spawned thread communicate to the parent thread when it has finished. This can be done via regular <a rel="external" href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc</code> channels</a>, and thus the parent thread just needs to wait for something to arrive over the channel instead of looping.</p><p>First, I wrote a function that spawns a new thread inside an existing thread scope, but this is a special thread: it will send its own handle to the parent thread. In my code, I call it a “self-shipping thread”. The function also receives the target function that we want to run in the new thread.</p><p>Let’s see how this function is implemented below, and then we’ll go through it step by step.</p><pre class="giallo z-code"><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p><code data-lang="rust" data-name="rust_self_shipping_threads_naive.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  7</span><span class="z-keyword">pub</span><span class="z-keyword"> fn</span><span class="z-entity z-name z-function"> spawn_self_shipping_thread_in_scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> F</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>(</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  8</span><span class="z-variable z-other">    scope</span><span class="z-keyword">:</span><span class="z-keyword"> &amp;</span><span>'</span><span class="z-entity z-name">scope</span><span class="z-entity z-name"> thread</span><span class="z-keyword">::</span><span class="z-entity z-name">Scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span> '</span><span class="z-entity z-name">_</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">  9</span><span class="z-variable z-other">    tx</span><span class="z-keyword">:</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name">Sender</span><span>&lt;</span><span class="z-entity z-name">ScopedJoinHandle</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 10</span><span class="z-variable z-other">    func</span><span class="z-keyword">:</span><span class="z-entity z-name"> F</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 11</span><span>)</span><span class="z-keyword"> where</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 12</span><span class="z-entity z-name">    F</span><span class="z-keyword">:</span><span class="z-entity z-name z-function"> FnOnce</span><span>(</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> R</span><span class="z-keyword"> +</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 13</span><span class="z-entity z-name">    R</span><span class="z-keyword">:</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 14</span><span>{</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 15</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Create the channel that will be used to transfer the new thread's handle from the parent</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 16</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> thread to the new thread.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 17</span><span class="z-storage z-type">    let</span><span> (</span><span class="z-variable z-other">handle_tx</span><span>,</span><span class="z-variable z-other"> handle_rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 18</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 19</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Spawn the new thread in the scope.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 20</span><span class="z-storage z-type">    let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> scope</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 21</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Execute the target function.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 22</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> result</span><span class="z-keyword"> =</span><span class="z-entity z-name z-function"> func</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 23</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 24</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Receive the handler that was sent by the parent thread to the new thread via the</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 25</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> channel.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 26</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle_rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 27</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> And immediately send it to the caller of `spawn_self_shipping_thread_in_scope`. It is</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 28</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> responsibility of the caller to make sure that the `rx` side of this channel is alive</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 29</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> until after this thread is finished.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 30</span><span class="z-variable z-other">        tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 31</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 32</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Return the same result as the target function.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 33</span><span class="z-variable z-other">        result</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 34</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 35</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 36</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Send the new thread's handle into the new thread itself.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 37</span><span class="z-variable z-other">    handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 38</span><span>}</span></span></code><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p></pre><p>The function receives three things: the thread scope in which the new threads will be created, the channel’s sending end which will be used the send the thread handle to the caller of <code>spawn_self_shipping_thread_in_scope</code>, and the target function we want to run in the new thread.</p><p>The function uses two channels:</p><ol><li>From parent thread to new thread: sends the handle to the new thread (created in line 17, used in lines 26 and 37).</li><li>From new thread to caller: returns the handle when the thread is finished (received from the caller in line 9, used in line 30).</li></ol><p>The parent thread creates the first channel, spawns the new thread, and sends the handle to it. Meanwhile, the new thread executes the target function, receives its own handle via the first channel, and sends it back to the caller through the second channel before returning the function’s result.</p><p>This is how <code>spawn_self_shipping_thread_in_scope</code> can be used:</p><pre class="giallo z-code"><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p><code data-lang="rust" data-name="rust_self_shipping_threads_naive.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 40</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> I'll call this function from my threads.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 41</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span class="z-keyword">:</span><span class="z-entity z-name"> u64</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> u64</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 42</span><span class="z-entity z-name z-function">    println!</span><span>(</span><span class="z-string">"</span><span class="z-string">Sleeping for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 43</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">sleep</span><span>(</span><span class="z-entity z-name">Duration</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">from_secs</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 44</span><span class="z-variable z-other">    sleep_duration</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 45</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 46</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 47</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 48</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Create the thread scope.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 49</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">scope</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-variable z-other">scope</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 50</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Create the channel that the new threads will use to send their handles to the main</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 51</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> thread.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 52</span><span class="z-storage z-type">        let</span><span> (</span><span class="z-variable z-other">handle_tx</span><span>,</span><span class="z-variable z-other"> handle_rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 53</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 54</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Spawn the new threads.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 55</span><span class="z-entity z-name z-function">        spawn_self_shipping_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">1</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 56</span><span class="z-entity z-name z-function">        spawn_self_shipping_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">3</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 57</span><span class="z-entity z-name z-function">        spawn_self_shipping_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">5</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 58</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 59</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Drop this `handle_tx` so that when all the threads are finished and all the `handle_tx`</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 60</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> clones are dropped, `handle_rx` will return `Err`.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 61</span><span class="z-entity z-name z-function">        drop</span><span>(</span><span class="z-variable z-other">handle_tx</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 62</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 63</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> start_time</span><span class="z-keyword"> =</span><span class="z-entity z-name"> Instant</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">now</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 64</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Receive the handle from the next thread that finishes.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 65</span><span class="z-keyword">        while</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Ok</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle_rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 66</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> Join the thread and get the result.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 67</span><span class="z-keyword">            match</span><span class="z-variable z-other"> handle</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">join</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 68</span><span class="z-entity z-name">                Ok</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span>)</span><span class="z-keyword"> =&gt;</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 69</span><span class="z-storage z-type">                    let</span><span class="z-variable z-other"> time_elapsed</span><span class="z-keyword"> =</span><span class="z-variable z-other"> start_time</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">elapsed</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">as_secs_f64</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 70</span><span class="z-entity z-name z-function">                    println!</span><span>(</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 71</span><span class="z-string">                        "</span><span class="z-string">{</span><span class="z-string">time_elapsed:.2</span><span class="z-string">}</span><span class="z-string">: Thread finished: slept for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 72</span><span>                    )</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 73</span><span>                }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 74</span><span class="z-entity z-name">                Err</span><span>(</span><span class="z-variable z-other">e</span><span>)</span><span class="z-keyword"> =&gt;</span><span class="z-entity z-name z-function"> eprintln!</span><span>(</span><span class="z-string">"</span><span class="z-string">Error joining thread: </span><span class="z-string">{</span><span class="z-string">e:?</span><span class="z-string">}</span><span class="z-string">"</span><span>)</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 75</span><span>            }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 76</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 77</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 78</span><span>}</span></span></code><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p></pre><p>When spawning the threads, you need to create the scope and the channel, spawn the threads by calling <code>spawn_self_shipping_thread_in_scope</code> while passing the scope, the <code>handle_tx</code> side of the channel, and the target function, and then just wait on the <code>handle_rx</code> side for the handles. As handles arrive, it is guaranteed that their threads have completed.</p><p>This is the result:</p><pre class="giallo z-code"><code data-lang="plain"><span class="giallo-l"><span>Sleeping for 1 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 3 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 5 seconds.</span></span>
<span class="giallo-l"><span>1.01: Thread finished: slept for 1 seconds.</span></span>
<span class="giallo-l"><span>3.00: Thread finished: slept for 3 seconds.</span></span>
<span class="giallo-l"><span>5.00: Thread finished: slept for 5 seconds.</span></span></code></pre><h2 id="but-what-if-the-thread-panics">But what if the thread panics?</h2><p>But the code above has a fatal flaw: what if the thread panics? Then, it won’t send the handle to the parent thread. Although the thread will eventually be joined when the scope ends, it will bypass our custom processing logic.</p><p>Let’s fix that.</p><p>First, let’s write a test that proves that we have a problem and that we can later use to prove that we have fixed the issue.</p><pre class="giallo z-code"><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p><code data-lang="rust" data-name="rust_self_shipping_threads_naive.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 87</span><span>        #</span><span>[</span><span>test</span><span>]</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 88</span><span class="z-keyword">        fn</span><span class="z-entity z-name z-function"> handles_panic</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 89</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> Create the thread scope.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 90</span><span class="z-entity z-name">            thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">scope</span><span>(</span><span class="z-keyword">|</span><span class="z-variable z-other">scope</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 91</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> And the channel.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 92</span><span class="z-storage z-type">                let</span><span> (</span><span class="z-variable z-other">tx</span><span>,</span><span class="z-variable z-other"> rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 93</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 94</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> Spawn the self-shipping thread. Make it panic.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 95</span><span class="z-entity z-name z-function">                spawn_self_shipping_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> tx</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 96</span><span class="z-entity z-name z-function">                    panic!</span><span>(</span><span class="z-string">"</span><span class="z-string">Thread is panicking on purpose for testing</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 97</span><span>                }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 98</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 99</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> Ensure something was sent over the channel.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">100</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">101</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> Join the self-shipping thread.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">102</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> join_result</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">join</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">103</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> And see that it errored with our custom panic message.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">104</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> err</span><span class="z-keyword"> =</span><span class="z-variable z-other"> join_result</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap_err</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">105</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> panic_msg</span><span class="z-keyword"> =</span><span class="z-variable z-other"> err</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">downcast_ref</span><span class="z-keyword">::</span><span>&lt;</span><span class="z-keyword">&amp;</span><span class="z-entity z-name">str</span><span>&gt;</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">106</span><span class="z-entity z-name z-function">                assert!</span><span>(</span><span class="z-variable z-other">panic_msg</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">contains</span><span>(</span><span class="z-string">"</span><span class="z-string">Thread is panicking on purpose for testing</span><span class="z-string">"</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">107</span><span>            }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">108</span><span>        }</span></span></code><p class="filename"><a href="rust_self_shipping_threads_naive.rs">Source: rust_self_shipping_threads_naive.rs</a></p></pre><p>Running the test, this is what we get:</p><pre class="giallo z-code"><code data-lang="plain"><span class="giallo-l"><span>thread 'tests::spawn_self_shipping_thread_in_scope::handles_panic' panicked at src/main.rs:98:40:</span></span>
<span class="giallo-l"><span>called `Result::unwrap()` on an `Err` value: RecvError</span></span></code></pre><p>The error comes from line 100: since nothing was ever sent into the channel before it was closed, calling <a rel="external" href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>recv</code></a> on it causes it to return an <code>Err</code>.</p><p>So, how do we make the test pass?</p><p>The idea here is this: no matter what happens, we always want the thread handle to be sent to the caller of <code>spawn_self_shipping_thread_in_scope</code>, even if the thread panics.</p><p>When a Rust thread panics, it goes through a process called <a rel="external" href="https://doc.rust-lang.org/nomicon/unwinding.html">“unwinding”</a>. During this process, everything in the thread stack is dropped as usual. <a rel="external" href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> implementations are still respected after panics! So we need to implement something that, when dropped, will send the handle through the channel.</p><p>What would such a thing look like? Let’s take a look.</p><pre class="giallo z-code"><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p><code data-lang="rust" data-name="rust_self_shipping_threads.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  7</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> A struct with a `Drop` implementation to ensure the thread handle is sent to the caller of</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  8</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> `spawn_self_shipping_thread_in_scope` even if the self-shipping thread panics.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  9</span><span class="z-storage z-type">struct</span><span class="z-entity z-name"> SendOnDrop</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 10</span><span class="z-variable z-other">    handle</span><span class="z-keyword">:</span><span class="z-entity z-name"> Option</span><span>&lt;</span><span class="z-entity z-name">ScopedJoinHandle</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 11</span><span class="z-variable z-other">    tx</span><span class="z-keyword">:</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name">Sender</span><span>&lt;</span><span class="z-entity z-name">ScopedJoinHandle</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 12</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 13</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 14</span><span class="z-keyword">impl</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span class="z-entity z-name"> Drop</span><span class="z-keyword"> for</span><span class="z-entity z-name"> SendOnDrop</span><span>&lt;</span><span>'</span><span class="z-entity z-name">_</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 15</span><span class="z-keyword">    fn</span><span class="z-entity z-name z-function"> drop</span><span>(</span><span class="z-keyword">&amp;</span><span class="z-storage">mut</span><span class="z-variable z-language"> self</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 16</span><span class="z-keyword">        if</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Some</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-language"> self</span><span class="z-keyword">.</span><span>handle</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">take</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 17</span><span class="z-variable z-language">            self</span><span class="z-keyword">.</span><span>tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 18</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 19</span><span>    }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 20</span><span>}</span></span></code><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p></pre><p>The struct <code>SendOnDrop</code> is something that owns the thread handle and <code>tx</code> (the sending end of the channel created by the caller of <code>spawn_self_shipping_thread_in_scope</code>). It implements the <code>Drop</code> trait, which requires an implementation for the <a rel="external" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>Drop::drop</code></a> method, and this is the method that runs when <code>SendOnDrop</code> is dropped.</p><p>The <code>Drop::drop</code> method will take ownership of the handle (that’s why its created as an <code>Option&lt;ScopedJoinHandle&lt;'scope, R&gt;&gt;</code> on the struct, so we can take ownership of it and leave a <code>None</code> in its place), and send it through the channel.</p><p>And here’s the version of <code>spawn_self_shipping_thread_in_scope</code> that makes use of the <code>SendOnDrop</code> struct:</p><pre class="giallo z-code"><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p><code data-lang="rust" data-name="rust_self_shipping_threads.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 22</span><span class="z-keyword">pub</span><span class="z-keyword"> fn</span><span class="z-entity z-name z-function"> spawn_self_shipping_thread_in_scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> F</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>(</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 23</span><span class="z-variable z-other">    scope</span><span class="z-keyword">:</span><span class="z-keyword"> &amp;</span><span>'</span><span class="z-entity z-name">scope</span><span class="z-entity z-name"> thread</span><span class="z-keyword">::</span><span class="z-entity z-name">Scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span> '</span><span class="z-entity z-name">_</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 24</span><span class="z-variable z-other">    tx</span><span class="z-keyword">:</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name">Sender</span><span>&lt;</span><span class="z-entity z-name">ScopedJoinHandle</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 25</span><span class="z-variable z-other">    func</span><span class="z-keyword">:</span><span class="z-entity z-name"> F</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 26</span><span>)</span><span class="z-keyword"> where</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 27</span><span class="z-entity z-name">    F</span><span class="z-keyword">:</span><span class="z-entity z-name z-function"> FnOnce</span><span>(</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> R</span><span class="z-keyword"> +</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 28</span><span class="z-entity z-name">    R</span><span class="z-keyword">:</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 29</span><span>{</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 30</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Create the channel that will be used to transfer the new thread's handle from the parent</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 31</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> thread to the new thread.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 32</span><span class="z-storage z-type">    let</span><span> (</span><span class="z-variable z-other">handle_tx</span><span>,</span><span class="z-variable z-other"> handle_rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 33</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 34</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Spawn the new thread in the scope.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 35</span><span class="z-storage z-type">    let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> scope</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 36</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Receive the handler that was sent by the parent thread to the new thread via the</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 37</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> channel.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 38</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle_rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 39</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 40</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> This will send the new thread's handle to the caller of</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 41</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> `spawn_self_shipping_thread_in_scope` when the thread stack is destroyed, even if that</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 42</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> happens due to a panic.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 43</span><span class="z-entity z-name">        SendOnDrop</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 44</span><span class="z-variable z-other">            handle</span><span class="z-keyword">:</span><span class="z-entity z-name"> Some</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 45</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> It is responsibility of the caller to make sure that the `rx` side of this</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 46</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> channel is alive until after this thread is finished.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 47</span><span class="z-variable z-other">            tx</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 48</span><span>        }</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 49</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 50</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Execute the target function and return its result.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 51</span><span class="z-entity z-name z-function">        func</span><span>(</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 52</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 53</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 54</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Send the new thread's handle into the new thread itself.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 55</span><span class="z-variable z-other">    handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 56</span><span>}</span></span></code><p class="filename"><a href="rust_self_shipping_threads.rs">Source: rust_self_shipping_threads.rs</a></p></pre><p>The body of the self-shipping thread changed significantly: now, the first thing it does is get the handle from the parent thread. Then, it creates a <code>SendOnDrop</code> struct on the stack. We don’t even need to give it a name: as long as it is sitting on the stack, it will be properly dropped in the event of a panic, or when the thread finishes.</p><p>Then, we run the target function and return its result.</p><p>And now, if we run the test from before, it passes! We now have self-shipping threads that we can act on immediately when they return, and they will still notify the caller of <code>spawn_self_shipping_thread_in_scope</code> when they finish, even if that happens because of a panic.</p><h2 id="exploring-an-alternative-approach">Exploring an alternative approach</h2><p>Alternatively, if a timely result is needed from a thread, it’s fairly common to pass that result to the interested thread via a channel, instead of arranging for the thread handle to be passed around and waiting for it to finish. If your function will be passing values to the parent thread via a channel regardless, then this is probably more appropriate, since most of the code will be in place already.</p><p>Otherwise, if all you care about is the return value of the function that you want to run in a separate thread, then the additional complexity may not be worth it.</p><p>Here’s what an implementation<sup><a id="footnote_ref__simpler-threads-sending-results-implementation" href="#footnote__simpler-threads-sending-results-implementation">1</a></sup> of that approach looks like:</p><pre class="giallo z-code"><p class="filename"><a href="rust_threads_sending_results.rs">Source: rust_threads_sending_results.rs</a></p><code data-lang="rust" data-name="rust_threads_sending_results.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 1</span><span class="z-keyword">use</span><span class="z-entity z-name"> std</span><span class="z-keyword">::</span><span>{</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 2</span><span class="z-entity z-name">    sync</span><span class="z-keyword">::</span><span>mpsc</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 3</span><span>    thread</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 4</span><span class="z-entity z-name">    time</span><span class="z-keyword">::</span><span>{</span><span class="z-entity z-name">Duration</span><span>,</span><span class="z-entity z-name"> Instant</span><span>}</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 5</span><span>}</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 6</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 7</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> spawn_thread_in_scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> F</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>(</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 8</span><span class="z-variable z-other">    scope</span><span class="z-keyword">:</span><span class="z-keyword"> &amp;</span><span>'</span><span class="z-entity z-name">scope</span><span class="z-entity z-name"> thread</span><span class="z-keyword">::</span><span class="z-entity z-name">Scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span> '</span><span class="z-entity z-name">_</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 9</span><span class="z-variable z-other">    tx</span><span class="z-keyword">:</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name">Sender</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">10</span><span class="z-variable z-other">    func</span><span class="z-keyword">:</span><span class="z-entity z-name"> F</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">11</span><span>)</span><span class="z-keyword"> where</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">12</span><span class="z-entity z-name">    F</span><span class="z-keyword">:</span><span class="z-entity z-name z-function"> FnOnce</span><span>(</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> R</span><span class="z-keyword"> +</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">13</span><span class="z-entity z-name">    R</span><span class="z-keyword">:</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">14</span><span>{</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">15</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Spawn the new thread in the scope.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">16</span><span class="z-variable z-other">    scope</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">17</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> result</span><span class="z-keyword"> =</span><span class="z-entity z-name z-function"> func</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">18</span><span class="z-variable z-other">        tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-variable z-other">result</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">19</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">20</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">21</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">22</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> I'll call this function from my threads.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">23</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span class="z-keyword">:</span><span class="z-entity z-name"> u64</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> u64</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">24</span><span class="z-entity z-name z-function">    println!</span><span>(</span><span class="z-string">"</span><span class="z-string">Sleeping for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">25</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">sleep</span><span>(</span><span class="z-entity z-name">Duration</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">from_secs</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">26</span><span class="z-variable z-other">    sleep_duration</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">27</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">28</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">29</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">30</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Create the thread scope.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">31</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">scope</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-variable z-other">scope</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">32</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Create the channel that the new threads will use to send their results to the main</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">33</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> thread.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">34</span><span class="z-storage z-type">        let</span><span> (</span><span class="z-variable z-other">tx</span><span>,</span><span class="z-variable z-other"> rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">35</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">36</span><span class="z-entity z-name z-function">        spawn_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">1</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">37</span><span class="z-entity z-name z-function">        spawn_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">3</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">38</span><span class="z-entity z-name z-function">        spawn_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">5</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">39</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">40</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Drop `tx` so that when all the threads are finished and all the `tx` clones are dropped,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">41</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> `rx` will return `Err`.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">42</span><span class="z-entity z-name z-function">        drop</span><span>(</span><span class="z-variable z-other">tx</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">43</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">44</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> start_time</span><span class="z-keyword"> =</span><span class="z-entity z-name"> Instant</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">now</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">45</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Receive the result from the next thread that sends one.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">46</span><span class="z-keyword">        while</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Ok</span><span>(</span><span class="z-variable z-other">result</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-other"> rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">47</span><span class="z-storage z-type">            let</span><span class="z-variable z-other"> time_elapsed</span><span class="z-keyword"> =</span><span class="z-variable z-other"> start_time</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">elapsed</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">as_secs_f64</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">48</span><span class="z-entity z-name z-function">            println!</span><span>(</span><span class="z-string">"</span><span class="z-string">{</span><span class="z-string">time_elapsed:.2</span><span class="z-string">}</span><span class="z-string">: Thread finished: slept for </span><span class="z-string">{</span><span class="z-string">result</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">49</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">50</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">51</span><span>}</span></span></code><p class="filename"><a href="rust_threads_sending_results.rs">Source: rust_threads_sending_results.rs</a></p></pre><p>No surprise, here’s the outcome:</p><pre class="giallo z-code"><code data-lang="plain"><span class="giallo-l"><span>Sleeping for 1 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 5 seconds.</span></span>
<span class="giallo-l"><span>Sleeping for 3 seconds.</span></span>
<span class="giallo-l"><span>1.01: Thread finished: slept for 1 seconds.</span></span>
<span class="giallo-l"><span>3.01: Thread finished: slept for 3 seconds.</span></span>
<span class="giallo-l"><span>5.01: Thread finished: slept for 5 seconds.</span></span></code></pre><p>But what if the thread panics? You may still want to handle panics in your code. This is where the additional complexity appears.</p><p>In that case, you’ll need to make sure that <code>func</code> is <a rel="external" href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html">“unwind-safe”</a>, meaning that when a panic happens inside, the program is still left in a state that it can continue to run without the risk of memory safety issues. Then, call <a rel="external" href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>panic::catch_unwind</code></a> when running the function and process the result, which could be an <code>Ok</code> variant carrying the return value from the function, or <code>Err</code> with the string that was passed into <code>panic!</code>. You may optionally choose to resume the unwinding with <a rel="external" href="https://doc.rust-lang.org/std/panic/fn.resume_unwind.html"><code>panic::resume_unwind</code></a>.</p><p>Here’s how that can be done:</p><pre class="giallo z-code"><p class="filename"><a href="rust_threads_sending_results_panic.rs">Source: rust_threads_sending_results_panic.rs</a></p><code data-lang="rust" data-name="rust_threads_sending_results_panic.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 1</span><span class="z-keyword">use</span><span class="z-entity z-name"> std</span><span class="z-keyword">::</span><span>{</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 2</span><span>    panic</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 3</span><span class="z-entity z-name">    sync</span><span class="z-keyword">::</span><span>mpsc</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 4</span><span>    thread</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 5</span><span class="z-entity z-name">    time</span><span class="z-keyword">::</span><span>{</span><span class="z-entity z-name">Duration</span><span>,</span><span class="z-entity z-name"> Instant</span><span>}</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 6</span><span>}</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 7</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 8</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> We'll use this enum to represent either a successful result or a panic.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln"> 9</span><span class="z-storage z-type">enum</span><span class="z-entity z-name"> ThreadResult</span><span>&lt;</span><span class="z-entity z-name">T</span><span>&gt;</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">10</span><span class="z-entity z-name z-function">    Success</span><span>(</span><span class="z-entity z-name">T</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">11</span><span class="z-entity z-name z-function">    Panic</span><span>(</span><span class="z-entity z-name">String</span><span>)</span><span>,</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">12</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">13</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">14</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> spawn_thread_in_scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span class="z-entity z-name"> F</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>(</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">15</span><span class="z-variable z-other">    scope</span><span class="z-keyword">:</span><span class="z-keyword"> &amp;</span><span>'</span><span class="z-entity z-name">scope</span><span class="z-entity z-name"> thread</span><span class="z-keyword">::</span><span class="z-entity z-name">Scope</span><span>&lt;</span><span>'</span><span class="z-entity z-name">scope</span><span>,</span><span> '</span><span class="z-entity z-name">_</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">16</span><span class="z-variable z-other">    tx</span><span class="z-keyword">:</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name">Sender</span><span>&lt;</span><span class="z-entity z-name">ThreadResult</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">17</span><span class="z-variable z-other">    func</span><span class="z-keyword">:</span><span class="z-entity z-name"> F</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">18</span><span>)</span><span class="z-keyword"> where</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">19</span><span class="z-entity z-name">    F</span><span class="z-keyword">:</span><span class="z-entity z-name z-function"> FnOnce</span><span>(</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> R</span><span class="z-keyword"> +</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span class="z-entity z-name"> panic</span><span class="z-keyword">::</span><span class="z-entity z-name">UnwindSafe</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">20</span><span class="z-entity z-name">    R</span><span class="z-keyword">:</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">scope</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">21</span><span>{</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">22</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Spawn the new thread in the scope.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">23</span><span class="z-variable z-other">    scope</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">24</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Catch any panic that might occur during the execution of the function.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">25</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> result</span><span class="z-keyword"> =</span><span class="z-entity z-name"> panic</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">catch_unwind</span><span>(</span><span class="z-variable z-other">func</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">26</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">27</span><span class="z-keyword">        match</span><span class="z-variable z-other"> result</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">28</span><span class="z-entity z-name">            Ok</span><span>(</span><span class="z-variable z-other">success</span><span>)</span><span class="z-keyword"> =&gt;</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">29</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> The function executed successfully.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">30</span><span class="z-variable z-other">                tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-entity z-name">ThreadResult</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">Success</span><span>(</span><span class="z-variable z-other">success</span><span>)</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">31</span><span>            }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">32</span><span class="z-entity z-name">            Err</span><span>(</span><span class="z-variable z-other">panic_info</span><span>)</span><span class="z-keyword"> =&gt;</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">33</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> Function panicked, extract panic message.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">34</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> panic_msg</span><span class="z-keyword"> =</span><span class="z-keyword"> if</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Some</span><span>(</span><span class="z-variable z-other">msg</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-other"> panic_info</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">downcast_ref</span><span class="z-keyword">::</span><span>&lt;</span><span class="z-keyword">&amp;</span><span class="z-entity z-name">str</span><span>&gt;</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">35</span><span>                    (</span><span class="z-keyword">*</span><span class="z-variable z-other">msg</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">to_string</span><span>(</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">36</span><span>                }</span><span class="z-keyword"> else</span><span class="z-keyword"> if</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Some</span><span>(</span><span class="z-variable z-other">msg</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-other"> panic_info</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">downcast_ref</span><span class="z-keyword">::</span><span>&lt;</span><span class="z-entity z-name">String</span><span>&gt;</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">37</span><span class="z-variable z-other">                    msg</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">38</span><span>                }</span><span class="z-keyword"> else</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">39</span><span class="z-string">                    "</span><span class="z-string">Unknown panic</span><span class="z-string">"</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">to_string</span><span>(</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">40</span><span>                }</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">41</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">42</span><span class="z-punctuation z-definition z-comment">                //</span><span class="z-comment"> Send the panic message.</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">43</span><span class="z-variable z-other">                tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-entity z-name">ThreadResult</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">Panic</span><span>(</span><span class="z-variable z-other">panic_msg</span><span>)</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">44</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">45</span><span class="z-entity z-name">                panic</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">resume_unwind</span><span>(</span><span class="z-variable z-other">panic_info</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">46</span><span>            }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">47</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">48</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">49</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">50</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">51</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> I'll call this function from my threads.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">52</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span class="z-keyword">:</span><span class="z-entity z-name"> u64</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> u64</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">53</span><span class="z-entity z-name z-function">    println!</span><span>(</span><span class="z-string">"</span><span class="z-string">Sleeping for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">54</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">sleep</span><span>(</span><span class="z-entity z-name">Duration</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">from_secs</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">55</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">56</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> To demonstrate panic handling, let's make it panic for a specific duration.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">57</span><span>    #</span><span>[</span><span>allow</span><span>(</span><span>clippy</span><span class="z-keyword">::</span><span>manual_assert</span><span>)</span><span>]</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">58</span><span class="z-keyword">    if</span><span class="z-variable z-other"> sleep_duration</span><span class="z-keyword"> ==</span><span class="z-constant"> 3</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">59</span><span class="z-entity z-name z-function">        panic!</span><span>(</span><span class="z-string">"</span><span class="z-string">Intentional panic in thread with sleep_duration = 3</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">60</span><span>    }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">61</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">62</span><span class="z-variable z-other">    sleep_duration</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">63</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">64</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">65</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">66</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Create the thread scope.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">67</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">scope</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-variable z-other">scope</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">68</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Create the channel that the new threads will use to send their results to the main</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">69</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> thread.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">70</span><span class="z-storage z-type">        let</span><span> (</span><span class="z-variable z-other">tx</span><span>,</span><span class="z-variable z-other"> rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">71</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">72</span><span class="z-entity z-name z-function">        spawn_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">1</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">73</span><span class="z-entity z-name z-function">        spawn_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">3</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">74</span><span class="z-entity z-name z-function">        spawn_thread_in_scope</span><span>(</span><span class="z-variable z-other">scope</span><span>,</span><span class="z-variable z-other"> tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">5</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">75</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">76</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Drop `tx` so that when all the threads are finished and all the `tx` clones are dropped,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">77</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> `rx` will return `Err`.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">78</span><span class="z-entity z-name z-function">        drop</span><span>(</span><span class="z-variable z-other">tx</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">79</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">80</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> start_time</span><span class="z-keyword"> =</span><span class="z-entity z-name"> Instant</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">now</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">81</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Receive the result from the next thread that sends one.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">82</span><span class="z-keyword">        while</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Ok</span><span>(</span><span class="z-variable z-other">thread_result</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-other"> rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">83</span><span class="z-storage z-type">            let</span><span class="z-variable z-other"> time_elapsed</span><span class="z-keyword"> =</span><span class="z-variable z-other"> start_time</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">elapsed</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">as_secs_f64</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">84</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">85</span><span class="z-keyword">            match</span><span class="z-variable z-other"> thread_result</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">86</span><span class="z-entity z-name">                ThreadResult</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">Success</span><span>(</span><span class="z-variable z-other">result</span><span>)</span><span class="z-keyword"> =&gt;</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">87</span><span class="z-entity z-name z-function">                    println!</span><span>(</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">88</span><span class="z-string">                        "</span><span class="z-string">{</span><span class="z-string">time_elapsed:.2</span><span class="z-string">}</span><span class="z-string">: Thread finished successfully: slept for </span><span class="z-string">{</span><span class="z-string">result</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">89</span><span>                    )</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">90</span><span>                }</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">91</span><span class="z-entity z-name">                ThreadResult</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">Panic</span><span>(</span><span class="z-variable z-other">panic_msg</span><span>)</span><span class="z-keyword"> =&gt;</span><span> {</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">92</span><span class="z-entity z-name z-function">                    println!</span><span>(</span><span class="z-string">"</span><span class="z-string">{</span><span class="z-string">time_elapsed:.2</span><span class="z-string">}</span><span class="z-string">: Thread panicked with message: </span><span class="z-string">{</span><span class="z-string">panic_msg</span><span class="z-string">}</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">93</span><span>                }</span></span>
<span class="giallo-l z-hl"><span aria-hidden="true" class="giallo-ln">94</span><span>            }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">95</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">96</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">97</span><span>}</span></span></code><p class="filename"><a href="rust_threads_sending_results_panic.rs">Source: rust_threads_sending_results_panic.rs</a></p></pre><p>First, we’ll need an enum to signal whether the thread finished successfully or not, that’s <code>ThreadResult</code> in the code above. Then, in the thread, call the target function wrapped in <code>panic::catch_unwind</code> (the function must be unwind-safe, otherwise that will give us a compiler error).</p><p>Then, process the result: if it is an <code>Ok</code> variant, then the target function completed successfully and the return value is wrapped in the <code>Ok</code>. Get the return value, wrap it inside <code>ThreadResult</code>, and send it into the channel. If it is <code>Err</code>, then you need to wrap the panic message in <code>ThreadResult::Panic</code>, send it into the channel, and resume the unwinding with <a rel="external" href="https://doc.rust-lang.org/std/panic/fn.resume_unwind.html"><code>panic::resume_unwind</code></a>.</p><p>Finally, process the <code>ThreadResult</code> in the parent thread as needed.</p><p>Since the threads are not being joined, you’ll still get messages in <code>stderr</code> warning that some threads have panicked. Depending on your specific situation, this may be a minor inconvenience.</p><h2 id="conclusion">Conclusion</h2><p>This post presents two ways to handle joining multiple threads immediately as they finish in Rust, in ways in which it is also possible to process the threads’ results or panics.</p><p>The first involves passing spawned thread handles from the parent thread to the spawned thread, and back when it is ready. The other involves passing values from the spawned threads to the parent thread directly. Each approach allows handling panics, but in different ways. The first approach leaves panic-handling to the Rust runtime, and trust the unwinding mechanism to pass the thread handles to the calling thread. The second approach handles panics explicitly in first-party code.</p><p>Whether to use the first or the second approach, it’s always a matter of judgement based on the specific situation in which we currently find ourselves, and a matter of personal preference if no approach offers an objective advantage.</p><p>When it’s just a matter of personal preference, I will probably prefer the first approach more often than the second, since leveraging the Rust runtime unwinding mechanism seems like a considerable advantage and an opportunity to reduce the complexity of my code by adhering better to Rust’s threading model: not having to handle panics explicitly, not having to worry about unwinding-safety, not having to worry about messages to <code>stderr</code>, etc.</p><h2 id="appendix-a">Appendix A: Does it work with regular threads too?</h2><p>This works with regular threads too, not only scoped threads. See the code below.</p><pre class="giallo z-code"><p class="filename"><a href="rust_self_shipping_regular_threads.rs">Source: rust_self_shipping_regular_threads.rs</a></p><code data-lang="rust" data-name="rust_self_shipping_regular_threads.rs"><span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  1</span><span class="z-keyword">use</span><span class="z-entity z-name"> std</span><span class="z-keyword">::</span><span>{</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  2</span><span class="z-entity z-name">    sync</span><span class="z-keyword">::</span><span>mpsc</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  3</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span>{</span><span class="z-variable z-language">self</span><span>,</span><span class="z-entity z-name"> JoinHandle</span><span>}</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  4</span><span class="z-entity z-name">    time</span><span class="z-keyword">::</span><span>{</span><span class="z-entity z-name">Duration</span><span>,</span><span class="z-entity z-name"> Instant</span><span>}</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  5</span><span>}</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  6</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  7</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> A struct with a `Drop` implementation to ensure the thread handle is sent to the caller of</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  8</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> `spawn_self_shipping_thread` even if the self-shipping thread panics.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">  9</span><span class="z-storage z-type">struct</span><span class="z-entity z-name"> SendOnDrop</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 10</span><span class="z-variable z-other">    handle</span><span class="z-keyword">:</span><span class="z-entity z-name"> Option</span><span>&lt;</span><span class="z-entity z-name">JoinHandle</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 11</span><span class="z-variable z-other">    tx</span><span class="z-keyword">:</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name">Sender</span><span>&lt;</span><span class="z-entity z-name">JoinHandle</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span>&gt;</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 12</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 13</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 14</span><span class="z-keyword">impl</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span class="z-entity z-name"> Drop</span><span class="z-keyword"> for</span><span class="z-entity z-name"> SendOnDrop</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 15</span><span class="z-keyword">    fn</span><span class="z-entity z-name z-function"> drop</span><span>(</span><span class="z-keyword">&amp;</span><span class="z-storage">mut</span><span class="z-variable z-language"> self</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 16</span><span class="z-keyword">        if</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Some</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-language"> self</span><span class="z-keyword">.</span><span>handle</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">take</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 17</span><span class="z-variable z-language">            self</span><span class="z-keyword">.</span><span>tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 18</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 19</span><span>    }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 20</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 21</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 22</span><span class="z-keyword">pub</span><span class="z-keyword"> fn</span><span class="z-entity z-name z-function"> spawn_self_shipping_thread</span><span>&lt;</span><span class="z-entity z-name">F</span><span>,</span><span class="z-entity z-name"> R</span><span>&gt;</span><span>(</span><span class="z-variable z-other">tx</span><span class="z-keyword">:</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name">Sender</span><span>&lt;</span><span class="z-entity z-name">JoinHandle</span><span>&lt;</span><span class="z-entity z-name">R</span><span>&gt;</span><span>&gt;</span><span>,</span><span class="z-variable z-other"> func</span><span class="z-keyword">:</span><span class="z-entity z-name"> F</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 23</span><span class="z-keyword">where</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 24</span><span class="z-entity z-name">    F</span><span class="z-keyword">:</span><span class="z-entity z-name z-function"> FnOnce</span><span>(</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> R</span><span class="z-keyword"> +</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">static</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 25</span><span class="z-entity z-name">    R</span><span class="z-keyword">:</span><span class="z-entity z-name"> Send</span><span class="z-keyword"> +</span><span> '</span><span class="z-entity z-name">static</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 26</span><span>{</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 27</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Create the channel that will be used to transfer the new thread's handle from the parent</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 28</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> thread to the new thread.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 29</span><span class="z-storage z-type">    let</span><span> (</span><span class="z-variable z-other">handle_tx</span><span>,</span><span class="z-variable z-other"> handle_rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 30</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 31</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Spawn the new thread in the scope.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 32</span><span class="z-storage z-type">    let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-entity z-name"> std</span><span class="z-keyword">::</span><span class="z-entity z-name">thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">spawn</span><span>(</span><span class="z-keyword">move</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 33</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Receive the handler that was sent by the parent thread to the new thread via the</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 34</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> channel.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 35</span><span class="z-storage z-type">        let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle_rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 36</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 37</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> This will send the new thread's handle to the caller of</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 38</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> `spawn_self_shipping_thread_in_scope` when the thread stack is destroyed, even if that</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 39</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> happens due to a panic.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 40</span><span class="z-entity z-name">        SendOnDrop</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 41</span><span class="z-variable z-other">            handle</span><span class="z-keyword">:</span><span class="z-entity z-name"> Some</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 42</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> It is responsibility of the caller to make sure that the `rx` side of this channel</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 43</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> is alive until after this thread is finished.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 44</span><span class="z-variable z-other">            tx</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 45</span><span>        }</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 46</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 47</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Execute the target function and return its result.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 48</span><span class="z-entity z-name z-function">        func</span><span>(</span><span>)</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 49</span><span>    }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 50</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 51</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Send the new thread's handle into the new thread itself.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 52</span><span class="z-variable z-other">    handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">send</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 53</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 54</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 55</span><span class="z-punctuation z-definition z-comment">//</span><span class="z-comment"> I'll call this function from my threads.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 56</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span class="z-keyword">:</span><span class="z-entity z-name"> u64</span><span>)</span><span class="z-keyword"> -&gt;</span><span class="z-entity z-name"> u64</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 57</span><span class="z-entity z-name z-function">    println!</span><span>(</span><span class="z-string">"</span><span class="z-string">Sleeping for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 58</span><span class="z-entity z-name">    thread</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">sleep</span><span>(</span><span class="z-entity z-name">Duration</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">from_secs</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 59</span><span class="z-variable z-other">    sleep_duration</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 60</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 61</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 62</span><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 63</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Create the channel that the new threads will use to send their handles to the main thread.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 64</span><span class="z-storage z-type">    let</span><span> (</span><span class="z-variable z-other">handle_tx</span><span>,</span><span class="z-variable z-other"> handle_rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 65</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 66</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Spawn the new threads.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 67</span><span class="z-entity z-name z-function">    spawn_self_shipping_thread</span><span>(</span><span class="z-variable z-other">handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">1</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 68</span><span class="z-entity z-name z-function">    spawn_self_shipping_thread</span><span>(</span><span class="z-variable z-other">handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">3</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 69</span><span class="z-entity z-name z-function">    spawn_self_shipping_thread</span><span>(</span><span class="z-variable z-other">handle_tx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">clone</span><span>(</span><span>)</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span class="z-entity z-name z-function"> target_fn</span><span>(</span><span class="z-constant">5</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 70</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 71</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Drop this `handle_tx` so that when all the threads are finished and all the `handle_tx`</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 72</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> clones are dropped, `handle_rx` will return `Err`.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 73</span><span class="z-entity z-name z-function">    drop</span><span>(</span><span class="z-variable z-other">handle_tx</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 74</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 75</span><span class="z-storage z-type">    let</span><span class="z-variable z-other"> start_time</span><span class="z-keyword"> =</span><span class="z-entity z-name"> Instant</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">now</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 76</span><span class="z-punctuation z-definition z-comment">    //</span><span class="z-comment"> Receive the handle from the next thread that finishes.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 77</span><span class="z-keyword">    while</span><span class="z-storage z-type"> let</span><span class="z-entity z-name"> Ok</span><span>(</span><span class="z-variable z-other">handle</span><span>)</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle_rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 78</span><span class="z-punctuation z-definition z-comment">        //</span><span class="z-comment"> Join the thread and get the result.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 79</span><span class="z-keyword">        match</span><span class="z-variable z-other"> handle</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">join</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 80</span><span class="z-entity z-name">            Ok</span><span>(</span><span class="z-variable z-other">sleep_duration</span><span>)</span><span class="z-keyword"> =&gt;</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 81</span><span class="z-storage z-type">                let</span><span class="z-variable z-other"> time_elapsed</span><span class="z-keyword"> =</span><span class="z-variable z-other"> start_time</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">elapsed</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">as_secs_f64</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 82</span><span class="z-entity z-name z-function">                println!</span><span>(</span><span class="z-string">"</span><span class="z-string">{</span><span class="z-string">time_elapsed:.2</span><span class="z-string">}</span><span class="z-string">: Thread finished: slept for </span><span class="z-string">{</span><span class="z-string">sleep_duration</span><span class="z-string">}</span><span class="z-string"> seconds.</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 83</span><span>            }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 84</span><span class="z-entity z-name">            Err</span><span>(</span><span class="z-variable z-other">e</span><span>)</span><span class="z-keyword"> =&gt;</span><span class="z-entity z-name z-function"> eprintln!</span><span>(</span><span class="z-string">"</span><span class="z-string">Error joining thread: </span><span class="z-string">{</span><span class="z-string">e:?</span><span class="z-string">}</span><span class="z-string">"</span><span>)</span><span>,</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 85</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 86</span><span>    }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 87</span><span>}</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 88</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 89</span><span>#</span><span>[</span><span>cfg</span><span>(</span><span>test</span><span>)</span><span>]</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 90</span><span class="z-storage z-type">mod</span><span class="z-entity z-name"> tests</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 91</span><span class="z-keyword">    use</span><span class="z-variable z-language"> super</span><span class="z-keyword">::</span><span class="z-keyword">*</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 92</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 93</span><span class="z-storage z-type">    mod</span><span class="z-entity z-name"> spawn_self_shipping_thread</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 94</span><span class="z-keyword">        use</span><span class="z-variable z-language"> super</span><span class="z-keyword">::</span><span class="z-keyword">*</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 95</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 96</span><span>        #</span><span>[</span><span>test</span><span>]</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 97</span><span class="z-keyword">        fn</span><span class="z-entity z-name z-function"> handles_panic</span><span>(</span><span>)</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 98</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> Create the channel.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln"> 99</span><span class="z-storage z-type">            let</span><span> (</span><span class="z-variable z-other">tx</span><span>,</span><span class="z-variable z-other"> rx</span><span>)</span><span class="z-keyword"> =</span><span class="z-entity z-name"> mpsc</span><span class="z-keyword">::</span><span class="z-entity z-name z-function">channel</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">100</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">101</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> Spawn the self-shipping thread. Make it panic.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">102</span><span class="z-entity z-name z-function">            spawn_self_shipping_thread</span><span>(</span><span class="z-variable z-other">tx</span><span>,</span><span class="z-keyword"> |</span><span class="z-keyword">|</span><span> {</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">103</span><span class="z-entity z-name z-function">                panic!</span><span>(</span><span class="z-string">"</span><span class="z-string">Thread is panicking on purpose for testing</span><span class="z-string">"</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">104</span><span>            }</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">105</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">106</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> Ensure something was sent over the channel.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">107</span><span class="z-storage z-type">            let</span><span class="z-variable z-other"> handle</span><span class="z-keyword"> =</span><span class="z-variable z-other"> rx</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">recv</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">108</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> Join the self-shipping thread.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">109</span><span class="z-storage z-type">            let</span><span class="z-variable z-other"> join_result</span><span class="z-keyword"> =</span><span class="z-variable z-other"> handle</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">join</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">110</span><span class="z-punctuation z-definition z-comment">            //</span><span class="z-comment"> And see that it errored with our custom panic message.</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">111</span><span class="z-storage z-type">            let</span><span class="z-variable z-other"> err</span><span class="z-keyword"> =</span><span class="z-variable z-other"> join_result</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap_err</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">112</span><span class="z-storage z-type">            let</span><span class="z-variable z-other"> panic_msg</span><span class="z-keyword"> =</span><span class="z-variable z-other"> err</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">downcast_ref</span><span class="z-keyword">::</span><span>&lt;</span><span class="z-keyword">&amp;</span><span class="z-entity z-name">str</span><span>&gt;</span><span>(</span><span>)</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">113</span><span class="z-entity z-name z-function">            assert!</span><span>(</span><span class="z-variable z-other">panic_msg</span><span class="z-keyword">.</span><span class="z-entity z-name z-function">contains</span><span>(</span><span class="z-string">"</span><span class="z-string">Thread is panicking on purpose for testing</span><span class="z-string">"</span><span>)</span><span>)</span><span>;</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">114</span><span>        }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">115</span><span>    }</span></span>
<span class="giallo-l"><span aria-hidden="true" class="giallo-ln">116</span><span>}</span></span></code><p class="filename"><a href="rust_self_shipping_regular_threads.rs">Source: rust_self_shipping_regular_threads.rs</a></p></pre><p><em>Edit 1 (2025-05-21): <a rel="external" href="https://github.com/ericseppanen">Eric Seppanen</a> offered some suggestions on how this post could be improved:</em></p><ul><li><em>I edited the post to mention that it is possible to just not join the threads at all, and let them run in “detached” mode.</em></li><li><em>I added <a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#exploring-an-alternative-approach">the section about an alternative approach</a> and <a href="https://jpmelos.com/posts/joining-multiple-rust-threads/#conclusion">the conclusion</a> comparing both approaches.</em></li></ul><div class="footnote-container"><div class="footnote-definition" id="footnote__simpler-threads-sending-results-implementation"><p>1. There’s a simpler way to achieve the same result: make the <code>target_fn</code> accept a <code>Sender</code>. However, I’m only interested in approaches that do not require changing the target function: it should work with any function, including from other crates. <a href="#footnote_ref__simpler-threads-sending-results-implementation">↩</a></p></div></div></div></div></div><div class="row posts-page-navigation posts-page-navigation-bottom"><div class="col-6"></div><div class="col-6"></div></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script><script>!function(){const t="theme-preference";function e(){const e=localStorage.getItem(t);return e||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}function n(t){document.documentElement.setAttribute("data-theme",t),function(t){const e=document.getElementById("css-syntax-highlighting-light"),n=document.getElementById("css-syntax-highlighting-dark");e&&e.remove();n&&n.remove();const c=document.createElement("link");c.rel="stylesheet",c.type="text/css","dark"===t?(c.id="css-syntax-highlighting-dark",c.href="https://jpmelos.com/static/css/syntax_highlighting_theme_dark.css?h=1a2a23433db612368497"):(c.id="css-syntax-highlighting-light",c.href="https://jpmelos.com/static/css/syntax_highlighting_theme_light.css?h=e440151f24aead5bf580");document.head.appendChild(c)}(t)}function c(){const c="dark"===(document.documentElement.getAttribute("data-theme")||e())?"light":"dark";localStorage.setItem(t,c),n(c)}n(e()),document.addEventListener("DOMContentLoaded",(function(){const t=document.getElementById("theme-toggle");t&&t.addEventListener("click",c)}))}()</script><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;ad1cb2b3b9ce401a8877b99ffd513a0d&quot;}"></script></body></html>